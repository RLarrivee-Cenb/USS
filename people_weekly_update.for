C	*****************************************************************
C
C	PEOPLE_WEEKLY_UPDATE
C
C	PROGRAM TO PERFORM A WEEKLY UPDATE OF THE PEOPLE_KEY1 FILE
C	TRANSFERRING THE INFO FROM THE CURRENT SCHEDULES.  THE
C	OCCUPATION, LOCATION AND SUBGROUP INFO IS USED BY THE
C	SAFETY AND OVERTIME PROGRAMS FOR VARIOUS LISTINGS.
C	ALSO, ON SUNDAY THE OLD SCHEDULE FILES ARE PURGED.
C
C	RUN AS A DETACHED PROCESS
C	03-NOV-1994  ALPHA VERSION
C
C	******************************************************************
C	LINK PEOPLE_WEEKLY_UPDATE,USER3:[RJW.LIB]GENERAL/LIB
C	*******************************************************************
C	17-APR-1989:  CHANGED TO USE NEW PEOPLE FILE STRUCTURE
C	01-NOV-1989:  Added the section that zeros the occupation code
C	              in the safety file of anyone who has a zero occupation
C		      in the people file.  This  is to delete any inactive
C		      people from reports such as LACK.
C	12-JUL-1990:  Added, saving the accounting location from the sched.
C		      in the PEOPLE file.
C	04-MAY-1992:  When zeroing out the people in the safety file
C		      don't write to err file if not found.
C	01-JUN-1992   Recompile using the new People structure that
C		      includes 9 digit zip.
C	05-OCT-1993:  Added; if sched.rem1=14 then store sched date as
C		      CITE training date in the PEOPLE record.
C	12-JAN-1994   Eliminted update of the safety file because new
C		      safety program does not require it.
C	17-NOV-1994   New People Structure.
C	19-DEC-1994   New ascii_to_dec for one day vacs.
C	****************************************************************
C
	IMPLICIT	INTEGER(A-Z)
	EXTERNAL	UFO_OPEN
	INCLUDE '($SSDEF)'
C
	STRUCTURE/SCHED_FILE/
		INTEGER*4	CK_NUM
		BYTE	     	PRINT_GROUP(3)
		INTEGER*4	SEQ		!SEQUENCE NUMBER
		INTEGER*2	OCCUP(3)
		BYTE 		CREW
		CHARACTER*13	NAME
		CHARACTER*7	SCHED(3)
		BYTE		WEEK
		BYTE		CGROUP
		BYTE		CPRIOR
		BYTE		CAREA
		CHARACTER*19	REM             !ASCII REMARK
		BYTE		REM1		!REMARK REF NUMBER
		BYTE		ACC_LOC
		BYTE		SFMEET
		BYTE		LOC
		BYTE		SUB
	END STRUCTURE
	RECORD/SCHED_FILE/SCHED
C
	INCLUDE	'STRUCTURES:PEOPLE_STR.LIS'
C
C
	STRUCTURE/SAFETY_RECORD/
		INTEGER*4	DATE(2)		!BINARY DATE
		BYTE		TYPE
		BYTE		GROUP           !SCHEDULE GROUP
		BYTE		LOC
		BYTE		SUB
		INTEGER*2	OCCUP
		INTEGER*2	FOR		!FOREMAN
		CHARACTER*13	RULE
		CHARACTER*50	COM
	END STRUCTURE
C
C
	STRUCTURE/SAFETY_FILE/
		INTEGER*4	CK_NUM
		CHARACTER*21	NAME
		INTEGER*2	OCCUP
		BYTE		SCHED_GROUP
		BYTE		LOC
		BYTE		SUB 
		BYTE		EMP_TYPE	!EMPLOYEE TYPE (WAGE=1 ETC)
		BYTE		OVER		!=1 MEANS THERE IS AN OVERFLOW
C						!OF RECORDS
		BYTE		ACC		!ACCOUNTING LOCATION
		INTEGER*2	RESPON		!RESPON
		BYTE		DUM(116)
		RECORD/SAFETY_RECORD/REC(199) 
	END STRUCTURE
	RECORD/SAFETY_FILE/SAF
C
C
	INTEGER*4	SCHED_GROUP
	INTEGER*4	STATUS
	INTEGER*4	FILE_ERR(5)
	INTEGER*4	IOS,ACCESS,LINE_COUNT
	INTEGER*4	CK_NUM(3000)
C
	CHARACTER*1	PSCHED_GROUP(5)/'1','2','3','4','5'/
	CHARACTER*1	TRANS/'0'/,MATCH/' '/
	CHARACTER*11	DATE_TEMP,DATE_1,SUN_DATE,SCHED_DATE
	CHARACTER*80	FILE_NAME(5) 	!SCHEDULE FILE NAMES
C
C
	INTEGER*4	RECORD,DAY
	INTEGER*4	REGISTER 
C
	CHARACTER*13		INV/'1 00:00:00.00'/	!24 HR WAKEUP
	CHARACTER*11	CURRENT1
	CHARACTER*23	DATE1
C
	CHARACTER*14	TIME1/'-- 03:00:00.00'/
	CHARACTER*8	NOW
	INTEGER*4	BIN1(2),BIN2(2),BIN3(2),DIFF(2),SUM(2)
	INTEGER*4	BIN4(2),P,Q
C
	INTEGER*4	DATE_REF,RFLAG
	CHARACTER*11	REF_DATE,PTEMP11
	CHARACTER*4	PERIOD		!PAY PERIOD AND WEEK
	CHARACTER*31	FILE/'SCHED:SCHED_*_19-JUN-1988.DAT;*'/
	CHARACTER*33	FILE1/'SCHED:XMIT_TEMP_19-JUN-1988.LIS;*'/
C
	DIFF(1)=711573504       !INTEGER (8 BYTES) REPRESENTING EXACTLY
	DIFF(2)=201             ! ONE DAY OF TIME
C	*** ON A RESTART; SCHEDULE THE PROGRAM TO RUN AT 3 AM AND
C	    REPEAT THE WAKEUP EVERY 24 HOURS ***************
5	ISTAT=SYS$BINTIM(TIME1,BIN1)
C
	ISTAT=SYS$BINTIM(INV,BIN2)
C
C	*** IF SCHEDULED WAKE UP GETS AN ERROR WAIT 30 MIN AND TRY AGAIN**
	ISTAT=SYS$SCHDWK(,,BIN1,BIN2)
	IF(ISTAT .EQ. SS$_IVTIME)THEN
		CALL LIB$WAIT(1800.)
		GOTO 5
	ELSE IF(ISTAT .EQ. SS$_NORMAL)THEN
		GOTO 40
	ELSE
		GOTO 9100	!SOME OTHER STATUS
	END IF
C
40	STATUS=SYS$HIBER()
C
C	*** CHECK WHAT DAY THIS IS ****
50	STATUS=SYS$ASCTIM(,DATE1,,)
	STATUS=SYS$BINTIM(DATE1,BIN3)
C	IF(.NOT. STATUS)CALL LIB$SIGNAL(%VAL(STATUS))
C
	STATUS=LIB$DAY_OF_WEEK(%REF(BIN3),%REF(DAY))
C	IF(.NOT. STATUS)CALL LIB$SIGNAL(%VAL(STATUS)
C
	IF(DAY .EQ. 7)THEN      !SUNDAY
		GOTO  7000	!PURGE SCHED FILES
	ELSE IF(DAY .EQ. 5)THEN !FRIDAY
		GOTO 100        !WEEKLY UPDATE OF PEOPLE FILE
	ELSE
		STATUS=SYS$HIBER()
C		IF( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
		GOTO 50
	END IF
C	*** GET CURRENT DATE (ALWAYS RUN ON FRIDAY) ****
100	CURRENT1(1:11)=DATE1(1:11)
C	*** FIND NEXT SUNDAY'S DATE ***

	DATE1(13:23)=' 00:00:00.00'	
	STATUS=SYS$BINTIM(%DESCR(DATE1),%REF(BIN1))
	IF(.NOT. STATUS)CALL LIB$SIGNAL(%VAL(STATUS))
	DO I=1,3
		STATUS=SYS$ASCTIM(,%DESCR(DATE1),%REF(BIN1),%VAL(0)) 
		IF(.NOT. STATUS)CALL LIB$SIGNAL(%VAL(STATUS))
		CURRENT1=DATE1(1:11)
		STATUS=LIB$ADDX(BIN1,DIFF,SUM)
		IF(.NOT. STATUS)CALL LIB$SIGNAL(%VAL(STATUS))
                BIN1(1)=SUM(1)
		BIN1(2)=SUM(2)
	END DO
C	*** REPLACE SPACES WITH ZEROS ********
	CALL STR$TRANSLATE(CURRENT1,CURRENT1,TRANS,MATCH)
C	*** ZERO THE CHECK NUMBER ARRAY *****
	DO I=1,3000
		CK_NUM(I)=0
	END DO
	DO I=1,5
		FILE_ERR(I)=0
	END DO
C
	OPEN(1,FILE='PDAT:PEOPLE_KEY1.DAT',
	1	STATUS='UNKNOWN',
	1	FORM='UNFORMATTED',
	1    	RECORDTYPE='FIXED',
	1	RECL=128,
	1	ORGANIZATION='INDEXED',
	1	KEY=(1:4:INTEGER),
	1	ACCESS='KEYED',
	1	USEROPEN=UFO_OPEN,SHARED)
C
	OPEN(2,FILE='PDAT:PEOPLE_WEEKLY_UPDATE.ERR',
	1	STATUS='UNKNOWN',ACCESS='APPEND')
C
C                           
C	OPEN(3,FILE='PDAT:WAGE_SAFETY_KEY1.DAT',
C	1	STATUS='UNKNOWN',
C	1	FORM='UNFORMATTED',
C	1	RECORDTYPE='FIXED',
C	1	RECL=3968,
C	1	ORGANIZATION='INDEXED',
C	1	KEY=(1:4:INTEGER),
C	1	ACCESS='KEYED',
C	1	SHARED)
C
C	** CONSTRUCT SCHEDULE FILE NAMES AND **
C	** OPEN SCHEDULE FILES **
260	DO I=1,5    
	FILE_NAME(I)='SCHED:SCHED_'//PSCHED_GROUP(I)//'_'//CURRENT1//'.DAT'
C	
 	OPEN((I+6),FILE=FILE_NAME(I),STATUS='OLD',ERR=300,
	1	ORGANIZATION='SEQUENTIAL',
	1	RECORDTYPE='FIXED',
	1	RECL=20,
	1	FORM='UNFORMATTED',
	1	USEROPEN=UFO_OPEN,SHARED,
	1	ACCESS='SEQUENTIAL')
290	CONTINUE
	END DO
C       *** DONE OPENING FILES SO GO PROCESS ***
	GOTO 401
C       *** SCHED FILE OPEN ERROR ***********
300	FILE_ERR(I)=1
	WRITE(2,302)I,CURRENT1
302	FORMAT(' ','FILE OPEN ERROR FOR GROUP# ',I1,' DATE: ',A11)
	GOTO 290
C	*** PROCESS THE SCHEDULE FILES ****
C	** NOT: IF PERSON HAS A SPLIT SCHEDULE HIS FIRST OCCUP ETC. IS THE
C		ONE STORED
401	DO I=7,11
		IF(FILE_ERR(I-6).EQ. 1)GOTO 1000 !FILE ERR FOR THIS SCHED GROUP
C						 ! SO SKIP
400		READ(I,END=1000,ERR=5000)SCHED
		IF(SCHED.CK_NUM .EQ. 0)GOTO 400  !SKIP ZEROED RECORDS
   		DO J=1,3000             !HAS THIS PERSON ALREADY BEEN PROCESSED?
		  IF(SCHED.CK_NUM .EQ. CK_NUM(J))GOTO 400 !YES SO SKIP
		  IF(CK_NUM(J).EQ.0)THEN  !NO STORE CHECK NUMBER AND CONTINUE
		    CK_NUM(J)=SCHED.CK_NUM
		    GOTO 409
		  END IF
		END DO
409		ACCESS=0
410		READ(1,KEY=SCHED.CK_NUM,IOSTAT=IOS,ERR=4000)PEOPLE
		    DO K=1,3       !SWITCH SCHEDULES
			PEOPLE.SCHED2(K)=PEOPLE.SCHED1(K)
		    END DO
		    DO K=1,3    !STORE CURRENT SCHEDULE
		CALL	ASCII_DEC(SCHED.SCHED(K),PEOPLE.SCHED1(K),STATUS)
		    END DO
C	** SWITCH OTHER VARIABLES AND STORE NEW *****
		    PEOPLE.OCCUP(3)=PEOPLE.OCCUP(2)
		    PEOPLE.OCCUP(2)=SCHED.OCCUP(1)
		    PEOPLE.LOC(3)=PEOPLE.LOC(2)
		    PEOPLE.LOC(2)=SCHED.LOC
		    PEOPLE.SUB_GRP(3)=PEOPLE.SUB_GRP(2)
		    PEOPLE.SUB_GRP(2)=SCHED.SUB
		    PEOPLE.CREW(3)=PEOPLE.CREW(2)
		    PEOPLE.CREW(2)=SCHED.CREW
 		    PEOPLE.SCHED_GRP2=PEOPLE.SCHED_GRP1
		    PEOPLE.SCHED_GRP1=I-6
		    PEOPLE.REM2=PEOPLE.REM1
		    PEOPLE.REM1=SCHED.REM1
		    PEOPLE.SCHED_DATE2=PEOPLE.SCHED_DATE1
		    PEOPLE.SCHED_DATE1=CURRENT1
		    IF(SCHED.REM1 .EQ.14)THEN !CITE TRAINING
			CALL DAYS_1(CURRENT1,P,Q,PTEMP11,BIN4)
			PEOPLE.CITE(1)=BIN4(1)
			PEOPLE.CITE(2)=BIN4(2)
		    END IF
		    PEOPLE.ACC_LOC2=PEOPLE.ACC_LOC1
		    PEOPLE.ACC_LOC1=SCHED.ACC_LOC
		    REWRITE(1)PEOPLE
		    GOTO 400
C	*** UPDATE SAFETY FILE (12-JAN-1994 DELETED; NEW SAFETY PROGRAM)
C		    ACCESS=0
C420		    READ(3,KEY=SCHED.CK_NUM,IOSTAT=IOS,ERR=4500)SAF
C		    SAF.OCCUP=SCHED.OCCUP(1)
C		    SAF.LOC=SCHED.LOC
C		    SAF.SUB=SCHED.SUB
C 		    SAF.SCHED_GROUP=I-6
C		    SAF.ACC=SCHED.ACC_LOC
C		    REWRITE(3)SAF
1000	CONTINUE
	END DO
C	*** READ THRU THE PEOPLE FILE AND ANYONE WITH A OCCUP=0
C	    (INACTIVE) IS ZEROED ALSO IN THE SAFETY FILE **********
C	CLOSE(1)
C	OPEN(1,FILE='PDAT:PEOPLE_KEY1.DAT',
C	1	STATUS='UNKNOWN',
C	1	FORM='UNFORMATTED',
C	1    	RECORDTYPE='FIXED',
C	1	RECL=128,
C	1	ORGANIZATION='INDEXED',
C	1	KEY=(1:4:INTEGER),
C	1	ACCESS='KEYED',
C	1	USEROPEN=UFO_OPEN,SHARED)
C
C1002	ACCESS=0
C1004	READ(1,IOSTAT=IOS,ERR=4600,END=1008)PEOPLE
C	UNLOCK (1)
C	IF(PEOPLE.OCCUP(1) .EQ. 0)THEN
C1007		ACCESS=0
C1006		READ(3,KEY=PEOPLE.CK_NUM,IOSTAT=IOS,ERR=4650)SAF
C		SAF.OCCUP=0
C		REWRITE(3)SAF
C	END IF
C	GOTO 1002
C       *** DONE SO GO BACK TO SLEEP *****
1008	GOTO 9000
C	*** PEOPLE FILE ERROR *****
4000	IF(IOS .EQ. 36)THEN
		WRITE(2,4002)SCHED.CK_NUM,CURRENT1
	ELSE IF(IOS .EQ. 52)THEN  !ERROR RECORD LOCKED
		CALL RECORD_DELAY
		ACCESS=ACCESS+1
		IF(ACCESS .GT. 100)THEN
		   WRITE(2,4004)SCHED.CK_NUM,CURRENT1
		    GOTO 400
		ELSE
		      	GOTO 410
		END IF
	ELSE
		WRITE(2,4006)SCHED.CK_NUM,CURRENT1
		GOTO 400
	END IF
	GOTO 400
C
4002	FORMAT(' ','INVALID CHECK NUMBER :',I5.5,' ',A11) 
4004	FORMAT(' ','RECORD LOCKED FOR CHECK NUMBER :',I5.5,' ',A11) 
4006	FORMAT(' ','PEOPLE FILE ERROR FOR CHECK NUMBER :',I5.5,' ',A11) 
C	*** SAFETY FILE ERROR *****
C4500	IF(IOS .EQ. 36)THEN
C		WRITE(2,4502)SCHED.CK_NUM,CURRENT1
C	ELSE IF(IOS .EQ. 52)THEN  !ERROR RECORD LOCKED
C		CALL RECORD_DELAY
C		ACCESS=ACCESS+1
C		IF(ACCESS .GT. 100)THEN
C		   WRITE(2,4504)SCHED.CK_NUM,CURRENT1
C		    GOTO 400
C		ELSE
C		      	GOTO 420
C		END IF
C	ELSE
C		WRITE(2,4506)SCHED.CK_NUM,CURRENT1
C		GOTO 400
C	END IF
C	GOTO 400
C
4502	FORMAT(' ','SAFETY INVALID CHECK NUMBER :',I5.5,' ',A11) 
4504	FORMAT(' ','SAFETY RECORD LOCKED FOR CHECK NUMBER :',I5.5,' ',A11) 
4506	FORMAT(' ','SAFETY FILE ERROR FOR CHECK NUMBER :',I5.5,' ',A11) 
C	*** PEOPLE FILE ERROR *****
C4600	IF(IOS .EQ. 52)THEN  !ERROR RECORD LOCKED
C		CALL RECORD_DELAY
C		ACCESS=ACCESS+1
C		IF(ACCESS .GT. 100)THEN
C		   WRITE(2,4004)PEOPLE.CK_NUM,CURRENT1
C		    GOTO 1002
C		ELSE
C		      	GOTO 1004
C		END IF
C	ELSE
C		WRITE(2,4006)PEOPLE.CK_NUM,CURRENT1
C		GOTO 1002
C	END IF
C	GOTO 1002
C
C	*** SAFETY FILE ERROR *****
C4650	IF(IOS .EQ. 36)THEN
C		GOTO 1002  !NO SAFETY RECORD SO SKIP
C	ELSE IF(IOS .EQ. 52)THEN  !ERROR RECORD LOCKED
C		CALL RECORD_DELAY
C		ACCESS=ACCESS+1
C		IF(ACCESS .GT. 100)THEN
C		   WRITE(2,4504)PEOPLE.CK_NUM,CURRENT1
C		    GOTO 1002
C		ELSE
C		      	GOTO 1006
C		END IF
C	ELSE
C		WRITE(2,4506)PEOPLE.CK_NUM,CURRENT1
C		GOTO 1002
C	END IF
C	GOTO 1002
C
C
C	*** SCHEDULE FILE READ ERROR ***
5000	WRITE(2,5002)(I-6),CURRENT1
5002	FORMAT(' ','SCHEDULE FILE READ ERROR FOR: ',I1,' ',A11) 
	GOTO 1000
C
C****************** WEEKLY PURGE OF THE SCHEDULE FILES ************
C
7000	OPEN(4,FILE='SCHED:SCHED_DATES5.DAT',
	1	STATUS='UNKNOWN',
	1	FORM='UNFORMATTED',
	1	ORGANIZATION='SEQUENTIAL',
	1	RECORDTYPE='FIXED',
	1	RECL=6,
	1	USEROPEN=UFO_OPEN,SHARED,
	1	ACCESS='DIRECT')
C
	OPEN(2,FILE='PDAT:SCHED_WEEKLY_PURGE.ERR',
	1	STATUS='UNKNOWN',ACCESS='APPEND')
C	*** GET CURRENT DATE (ALWAYS RUN ON SUNDAY) ****
	CURRENT1(1:11)=DATE1(1:11)
	CALL STR$TRANSLATE(CURRENT1,CURRENT1,TRANS,MATCH)
C	**** READ SCHED DATES FILE TO FIND A MATCH ****
	RECORD=1
7100	READ(4,REC=RECORD,ERR=7200)DATE_REF,REF_DATE,PERIOD,RFLAG
	CALL STR$TRANSLATE(REF_DATE,REF_DATE,TRANS,MATCH)
C
	IF(REF_DATE .EQ. CURRENT1)THEN
		RECORD=RECORD-4    !BACK UP FOUR WEEKS
		READ(4,REC=RECORD,ERR=7200)DATE_REF,REF_DATE,PERIOD,RFLAG
		GOTO 7500
	END IF
C
	RECORD=RECORD+1
	GOTO 7100
C	*** FILE ERROR **********
7200	WRITE(2,7202)CURRENT1
7202	FORMAT(' ','ERROR READING SCHED DATE FILE: ',A11)
	GOTO 7900
C	**** PURGE THE FILES ********
7500	FILE(15:25)=REF_DATE    !DELETE SCHED FILES FROM 4 WEEKS AGO
	FILE1(17:27)=REF_DATE   !DELETE TRANSMIT FILE FROM 4 WEEKS AGO
C	***DELETE THE FILES ***
	STATUS=LIB$DELETE_FILE(FILE)
	STATUS=LIB$DELETE_FILE(FILE1)
C
7900	CLOSE(4)
	CLOSE(2)
	STATUS=SYS$HIBER()
C	IF( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	GOTO 50

C	*** CLOSE FILES AND HIBERNATE ************
9000	DO I=7,11
		CLOSE(I)
	END DO
	CLOSE(1)
	CLOSE(2)
	CLOSE(3)
	STATUS=SYS$HIBER()
	GOTO  50
9100	END
                              
