C
	PROGRAM GRATECTL3	!GRATE CONTROL PROGRAM FOR AGGL 3
C
C	(GRATE CONTROL STEP 3 AGGLOMERATOR)
C
C	THIS PROGRAM RUNS EVERY 2 SECONDS AND CONTROLS THE SPEED
C	OF THIS GRATE DRIVE AND THE 032 BELT FOR LINES 6 & 7 AGGL
C
	IMPLICIT NONE
C
C
C	REVISION 07-23-2007 032 BELT SPEED LINE 7 FOR 5 DRUMS HAS BEEN
C	SET TO 300 IPM PER RON BRASKI SERVICE CENTER TICKET PM704781
C
C	REVISION 10-24-2008 032 BELT SPEED LINE 6 FOR 5 DRUMS HAS BEEN
C	SET TO 275 IPM PER TERESA SIMETKOSKY SERVICE CENTER TICKET IM461770
C	WJ BABICH
C
C	REVISION 11-13-2008 032 BELT SPEED LINE 6 FOR 5 DRUMS HAS BEEN
C	SET TO 265 IPM PER TERESA SIMETKOSKY SERVICE CENTER TICKET IM471201
C	WJ BABICH
C
C	REVISION 03-18-2009 032 BELT SPEED LINE 7 FOR 5 DRUMS HAS BEEN
C	SET TO 285 IPM PER TERESA SIMETKOSKY SERVICE CENTER TICKET IM523166
C	WJ BABICH
C
C	REVISION 08-19-2009 032 BELT SPEED LINE 6 FOR 5 DRUMS HAS BEEN
C	SET TO 254 IPM PER LUCAS GRESCHNER SERVICE CENTER TICKET IM580059
C	WJ BABICH
C
C	REVISION 10-28-2010 032 BELT SPEED LINE 6 FOR 5 DRUMS HAS BEEN
C	SET TO 224 IPM PER TERESA SIMETKOSKY SERVICE CENTER TICKET IM580059
C	WJ BABICH
C
C	REVISION 04-21-2011 032 BELT SPEED LINE 6 FOR 5 DRUMS HAS BEEN
C	SET TO 210 IPM PER TERESA SIMETKOSKY SERVICE CENTER TICKET IM811922
C	BA PERANDER
C
C	REVISION 11-15-2011 032 BELT SPEED LINE 6 FOR 5 DRUMS HAS BEEN
C	SET TO 225 IPM PER TERESA SIMETKOSKY SERVICE CENTER TICKET IM897265
C	BA PERANDER
C
C	REVISION 5-16-2016 032 BELT SPEED LINE 7 FOR 5 DRUMS HAS BEEN
C	SET TO 275 IPM PER ERIC LACKSONEN FROM 285 IPM
C	BA PERANDER
C
C	
C       FORT/ALIGN=NONE/WARN=NOALIGNMENT/FLOAT=D_FLOAT GRATECTL3
C	LINK GRATECTL3,GRATECTL3/OPT,WESAPI_LIB:WESAPI/OPT
C	RUN/DET/NOACC/ERR=CTL:GRATECTL3.ERR/PRIOR=5/PROC=GRATECTL3 CTL:GRATECTL3
C
	INCLUDE 'WESAPI:SPD.DCL'
	INCLUDE 'WESAPI:SHC_defines.DCL'
	INCLUDE 'WESAPI:SHC_err.DCL'
C
	INTEGER*4	LIB$SYS_TRNLOG
	INTEGER*4 	status
	CHARACTER*20	highway

	CHARACTER*40    spd_filename
	INTEGER*2	spd_filename_len
	INTEGER*2	spd_fd
	INTEGER*2	access_type
	INTEGER*2	c_short_val
	CHARACTER*2	field_name
	CHARACTER*8	pt_name
	BYTE		extended_flag
	BYTE		gp_bit_num
	BYTE		inactive_flag
	BYTE		c_byte_val
	INTEGER*4	gp_sid
	INTEGER*2       get_pkd_group_val
	INTEGER*2       get_pkd_group_stat
	INTEGER*2       gp_force_stat
	INTEGER*2       gp_op_mask
	INTEGER*2       gp_val_mask
	INTEGER*2	AS(32)
	BYTE		gp_bitnum 
	INTEGER*2	digital_val
	INTEGER*2	digital_valx
	INTEGER*2	digital
	INTEGER*2	digital_stat
	INTEGER*2	TIMEOUT
C
	REAL            put_analog_val
	INTEGER*2	PUT_DIGITAL_VAL
C
	INTEGER*4	LEN,POINT_QUALITY
C
	CHARACTER*8	TIME/'0 0:0:02'/
C
	REAL*4		TIMEX,
	1		PM24/86400.0/,
	1		TEMP,
	1		CHECK,
	1		INCH32/185/,
	1		TOT(2),
	1		DRUMSF(2),
	1		LTH6(10),
	1		LTH7(10),
	1		ACCUM,
	1		OBS
C
	INTEGER*4	CADO,GSPD6,GSPD7,SPD326,SPD327,LTPH6,LTPH7
	INTEGER*4	UFO_OPEN
C
	INTEGER*4	CONTRL(2)
	REAL*4		PRGLSP(2),
	1		LVLPRN(2),
	1		LVOBAS(2),
	1		LVLOUT(2),
	1		SPDSET(2),
	1		SPDPRN(2),
	1		OUTBAS(2),
	1		OUTPUT(2),
	1		SPDO32(2),
	1		LTPH(2),
	1		LVSPI(2),
	1		LVSPD(2),
	1		LVSPP(2),
	1		SPOUTI(2),
	1		SPOUTD(2),
	1		SPOUTP(2),
	1		LVLHI(2),
	1		LVLLO(2),
	1		SPDHI(2),
	1		SPDLO(2),
	1		CNTLSP(2),
	1		CRTLSP(2),
	1		LVLPRO(2),
	1		SPDPRO(2),
	1		SPDS32(2),
	1		SPDN32(2),
	1		SPDL32(2),
	1		SPDB32(2),
	1		OUT32I(2),
	1		OUT32D(2),
	1		OUT32P(2),
	1		SP32LO(2),
	1		SP32HI(2)
	REAL*4		SET326(32)/260,260,260,260,260,260,260,220,
	1		           260,260,260,205,260,205,160,228,
	1		           260,260,260,260,260,270,165,293,
	1			   260,260,230,311,150,293,245,225/
	REAL*4		SET327(32)/260,260,260,260,260,260,260,200,
	1			   260,260,260,245,260,260,190,240,
	1			   260,260,260,345,260,305,260,290,
	1		           260,330,285,315,180,300,240,275/
C
	REAL*4		ANVAL(1000),
	1		NEWVAL(300),
	1		TOTL(256),
	1		FORTIM(10)
C
	INTEGER*4	AO(4),DO(1),AI(32)
	INTEGER*4	TEMPX
	INTEGER*4	CXSAVE(10),
	1		GPT(40)
	INTEGER*4	I,J,K,L,M,N,ADDRESS(2),BIT,BITX
C	INTEGER*4	GBBELT(10)/351,352,353,354,355,
C	1		           558,559,560,561,562/
	INTEGER*4	BDRUM(10)
	INTEGER*4	GBF(10)
	INTEGER*4	GBR(10)
C	INTEGER*4	GROUP(10)/10,6,3,0,5, 	!OLD TIMES
C	1			  15,11,6,3,0/
	INTEGER*4	GROUP(10)/11,7,4,3,8,   !NEW TIMES PER BILL SCOTT
	1			  13,10,9,7,3/  !ON 10/23/00
	INTEGER*4	STUFF(4)/900,901,902,903/
	INTEGER*4	B32(2)
	INTEGER*4	GBSCLEX(10)/2,7,12,17,22,
	1		            181,185,189,193,197/
	INTEGER*4	BEDSPX(2)/550,551/,
	1		CTRLCX(2),
	1		BCTLCX(2),
	1		GRATCX(2)
	INTEGER*4	DI(38)
C
	REAL*4		VALU(32)
	REAL*4		SKIP,
	1		GBSCLE(10),
	1		B27(10),
	1		BEDSP(2),
	1		BEDLVL(2),
	1		SPD32(2),
	1		SPDG(2),
	1		CSPDG(2),
	1		CSPD32(2)
C
	CHARACTER*23	DATETIME
C
	CHARACTER*8	DIP(38)/'DI803023','DI803113','DI803203',
	1			'DI83X023','DI83X113','DI805023',
	1			'DI805113','DI805203','DI85X023',
	1			'DI85X113','DI803066','DI803156',
	1			'DI803246','DI83X066','DI83X156',
	1			'DI805066','DI805156','DI805246',
	1			'DI85X066','DI85X156','DI803067',
	1			'DI803157','DI803247','DI83X067',
	1			'DI83X157','DI805067','DI805157',
	1			'DI805247','DI85X067','DI85X157',
	1			'DI803291','DI805291','DC811012',
	1			'DC813012','DC811011','DC813011',
	1			'DI804072','DI806072'/
C
	CHARACTER*8	AOP(4)/'AV800005','AV800006','AV800003',
	1		       'AV800004'/
C
	CHARACTER*8	DOP/'DV800002'/
C
	CHARACTER*8	AIP(32)/'AI811001','AI811007','AI811013','AI811019',
	1			'AI811025','AI813007','AI813011','AI813015',
	1			'AI813019','AI813023','AI811000','AI811006',
	1			'AI811012','AI811018','AI811024','AI813006',
	1			'AI813010','AI813014','AI813018','AI813022',
	1			'S012X011','S014X011','AI812000','AI814001',
	1			'AI811031','AI813032','AI812001','AI814002',
	1			'AO812000','AO814007','AO811015','AO813015'/
C
	COMMON/AG3_ANVALTBL/ANVAL
	COMMON/GRATETBL3/NEWVAL,TOTL,FORTIM,CXSAVE
	COMMON/GRATEFILE3/CONTRL,PRGLSP,LVLPRN,LVOBAS,
	1		 LVLOUT,SPDSET,SPDPRN,OUTBAS,
	1		 OUTPUT,SPDO32,LTPH,LVSPI,
	1		 LVSPD,LVSPP,SPOUTI,SPOUTD,
	1		 SPOUTP,LVLHI,LVLLO,SPDHI,
	1		 SPDLO,CNTLSP,CRTLSP,LVLPRO,
	1		 SPDPRO,SPDS32,SPDN32,SPDL32,
	1		 SPDB32,OUT32I,OUT32D,OUT32P,
	1		 SP32LO,SP32HI
C
	COMMON/AG3_GOODPTTBL/GPT
C
	EQUIVALENCE	(VALU(1),GBSCLE(1))
	EQUIVALENCE	(VALU(2),GBSCLE(2))
	EQUIVALENCE	(VALU(3),GBSCLE(3))
	EQUIVALENCE	(VALU(4),GBSCLE(4))
	EQUIVALENCE	(VALU(5),GBSCLE(5))
	EQUIVALENCE	(VALU(6),GBSCLE(6))
	EQUIVALENCE	(VALU(7),GBSCLE(7))
	EQUIVALENCE	(VALU(8),GBSCLE(8))
	EQUIVALENCE	(VALU(9),GBSCLE(9))
	EQUIVALENCE	(VALU(10),GBSCLE(10))
	EQUIVALENCE	(VALU(11),B27(1))
	EQUIVALENCE	(VALU(12),B27(2))
	EQUIVALENCE	(VALU(13),B27(3))
	EQUIVALENCE	(VALU(14),B27(4))
	EQUIVALENCE	(VALU(15),B27(5))
	EQUIVALENCE	(VALU(16),B27(6))
	EQUIVALENCE	(VALU(17),B27(7))
	EQUIVALENCE	(VALU(18),B27(8))
	EQUIVALENCE	(VALU(19),B27(9))
	EQUIVALENCE	(VALU(20),B27(10))
	EQUIVALENCE	(VALU(21),BEDSP(1))
	EQUIVALENCE	(VALU(22),BEDSP(2))
	EQUIVALENCE	(VALU(23),BEDLVL(1))
	EQUIVALENCE	(VALU(24),BEDLVL(2))
	EQUIVALENCE	(VALU(25),SPD32(1))
	EQUIVALENCE	(VALU(26),SPD32(2))
	EQUIVALENCE	(VALU(27),SPDG(1))
	EQUIVALENCE	(VALU(28),SPDG(2))
	EQUIVALENCE	(VALU(29),CSPDG(1))
	EQUIVALENCE	(VALU(30),CSPDG(2))
	EQUIVALENCE	(VALU(31),CSPD32(1))
	EQUIVALENCE	(VALU(32),CSPD32(2))
C
	EQUIVALENCE	(DI(1),BDRUM(1))
	EQUIVALENCE	(DI(2),BDRUM(2))
	EQUIVALENCE	(DI(3),BDRUM(3))
	EQUIVALENCE	(DI(4),BDRUM(4))
	EQUIVALENCE	(DI(5),BDRUM(5))
	EQUIVALENCE	(DI(6),BDRUM(6))
	EQUIVALENCE	(DI(7),BDRUM(7))
	EQUIVALENCE	(DI(8),BDRUM(8))
	EQUIVALENCE	(DI(9),BDRUM(9))
	EQUIVALENCE	(DI(10),BDRUM(10))
C
	EQUIVALENCE	(DI(11),GBF(1))
	EQUIVALENCE	(DI(12),GBF(2))
	EQUIVALENCE	(DI(13),GBF(3))
	EQUIVALENCE	(DI(14),GBF(4))
	EQUIVALENCE	(DI(15),GBF(5))
	EQUIVALENCE	(DI(16),GBF(6))
	EQUIVALENCE	(DI(17),GBF(7))
	EQUIVALENCE	(DI(18),GBF(8))
	EQUIVALENCE	(DI(19),GBF(9))
	EQUIVALENCE	(DI(20),GBF(10))
C
	EQUIVALENCE	(DI(21),GBR(1))
	EQUIVALENCE	(DI(22),GBR(2))
	EQUIVALENCE	(DI(23),GBR(3))
	EQUIVALENCE	(DI(24),GBR(4))
	EQUIVALENCE	(DI(25),GBR(5))
	EQUIVALENCE	(DI(26),GBR(6))
	EQUIVALENCE	(DI(27),GBR(7))
	EQUIVALENCE	(DI(28),GBR(8))
	EQUIVALENCE	(DI(29),GBR(9))
	EQUIVALENCE	(DI(30),GBR(10))
C
	EQUIVALENCE	(DI(31),B32(1))
	EQUIVALENCE	(DI(32),B32(2))
C
	EQUIVALENCE	(DI(33),CTRLCX(1))
	EQUIVALENCE	(DI(34),CTRLCX(2))
C
	EQUIVALENCE	(DI(35),BCTLCX(1))
	EQUIVALENCE	(DI(36),BCTLCX(2))
C
	EQUIVALENCE	(DI(37),GRATCX(1))
	EQUIVALENCE	(DI(38),GRATCX(2))
C
	EXTERNAL	UFO_OPEN
C
5	CONTINUE
C
C	OPEN CONNECTION TO AGGL 3 POINT DIRECTORY
C
        status = LIB$SYS_TRNLOG('WESAPI_PDIR_1',
     1			spd_filename_len,spd_filename,,,)
C
	spd_filename(spd_filename_len+1:) = CHAR(0)
C
        access_type = RUNTIME
C
        spd_fd = SPD_open_file(%ref(spd_filename), access_type)
C
	DO 20	J=1,4	!GET THE 4 AGGL 3 ANALOG OUTPUT SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(AOP(J)//char(0)),AO(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
20	CONTINUE
C
C                   GET COMPUTER ACKNOWLEDGE DO SID
C
	        status = SPD_get_sid(spd_fd,%ref(DOP//char(0)),DO,
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
	DO 30	J=1,32	!GET THE 32 AGGL 3 PROCESS VARIABLES SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(AIP(J)//char(0)),AI(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
30	CONTINUE
C
	DO 31	J=1,38	!GET THE 38 AGGL 3 DIGITAL INPUT SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(DIP(J)//char(0)),DI(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
31	CONTINUE
C
C  Close the point directory connection
C
	status = SPD_close_file(spd_fd)
C
C  Open the connection to SHC memory for WESAPI access
	status = SHC_open_memory()
C
	IF (status .NE. SHC_OK) THEN
		IF (status .EQ. SHC_E_MEMOPEN)GOTO 88
C
		OPEN	(UNIT=22,FILE='CTL:GRATE3.ERR',STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
		WRITE	(22,77)status
77		FORMAT	(' SHC open memory failure - error =',I4)
C
		CLOSE	(UNIT=22)
C
	   GO TO 99999
C
	ENDIF
C
88	CONTINUE
C
	OPEN	(UNIT=1,FILE='CTL:GRATE3.DAT',STATUS='NEW',
	1	RECL=68,ACCESS='DIRECT',RECORDTYPE='FIXED',
	1	FORM='UNFORMATTED',SHARED,USEROPEN=UFO_OPEN)
C
	READ	(1,REC=1)CONTRL,PRGLSP,LVLPRN,LVOBAS,
	1		 LVLOUT,SPDSET,SPDPRN,OUTBAS,
	1		 OUTPUT,SPDO32,LTPH,LVSPI,
	1		 LVSPD,LVSPP,SPOUTI,SPOUTD,
	1		 SPOUTP,LVLHI,LVLLO,SPDHI,
	1		 SPDLO,CNTLSP,CRTLSP,LVLPRO,
	1		 SPDPRO,SPDS32,SPDN32,SPDL32,
	1		 SPDB32,OUT32I,OUT32D,OUT32P,
	1		 SP32LO,SP32HI
C
	CLOSE	(UNIT=1)
C
	CALL	SYS$BINTIM(TIME,ADDRESS)
	CALL	SYS$SCHDWK(,,ADDRESS,ADDRESS)
C
100	CONTINUE
C
	DO 150	I=1,32	!READ IN THE 32 PROCESS VALUES NEEDED FOR THIS PASS
C
		status = SHC_get_analog_val_stat( AI(I), valu(I), AS(I))
C
150	CONTINUE
C
	DO 300	I=290,1,-1
		NEWVAL(I+10)=NEWVAL(I)	!SHUFFLE DOWN STREAM BLOCK
300	CONTINUE
C
	DO 400	I=1,10
C
		status = SHC_get_digital_val_stat(GBF(I), gp_sid,gp_bitnum,
	1	digital_val, digital_stat)	!CHECK FEED M-CX
C
		status = SHC_get_digital_val_stat(GBR(I), gp_sid,gp_bitnum,
	1	digital_valx, digital_stat)     !CHECK REVERSE M-CX
C
		digital=digital_val+digital_valx !MERGE THE TWO BITS
C
		IF (digital .EQ. 0)GOTO 340	!30 BELT OFF GO HERE
c
		status = SHC_get_digital_val_stat(BDRUM(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat)
C
		IF (digital_val .EQ. 0)GOTO 350	!BALL DRUM OFF GO HERE
C
		status = SHC_get_digital_val_stat(GBR(I), gp_sid,gp_bitnum,
	1	digital_val, digital_stat)     !CHECK REVERSE M-CX
C
		IF (digital_val .EQ. 1)GOTO 340	!30 BELT IN REV GO HERE
C
		BIT=digital_val
c
		TIMEX=SECNDS(0.0)	!GRAB TIME IN SECONDS
		IF ((BIT-CXSAVE(I)) .NE. 0) THEN
			FORTIM(I)=TIMEX	!BELT CHANGED TO FORWARD
			GOTO 350	!THIS SCAN ...SAVE TIME
		END IF
C
		IF ((TIMEX-FORTIM(I)) .LT. 0) TIMEX=TIMEX+PM24
C
		IF ((TIMEX-FORTIM(I)-30.0) .GT. 0)THEN	!IF MORE THAN 30 SEC
			NEWVAL(I)=GBSCLE(I)	!AGO GB SCALE OK
			GOTO 355
		END IF
C
		CALL	CHKGPT(GBSCLEX(I),BIT)	!CHECK GPT ON SCALE
		IF (BIT .EQ. 1) THEN	!IF READING IS GOOD USE IT
			NEWVAL(I)=GBSCLE(I)
			GOTO 355
		END IF
C
		IF ((TIMEX-FORTIM(I)-5.0) .LT. 0)GOTO 350!LESS THAN 5 SEC 
C
		TEMP=B27(I)	!OTHERWISE USE 27 BELT TONS
		TEMP=TEMP*2		!DOUBLE THEM
		NEWVAL(I)=TEMP
		GOTO 355
C
340		CONTINUE
C
350		CONTINUE
		NEWVAL(I)=0.0			!ZERO TONS THIS BELT
355		CONTINUE
C
		status = SHC_get_digital_val_stat(GBR(I), gp_sid,gp_bitnum,
	1	digital_val, digital_stat)     !CHECK REVERSE M-CX
C
		CXSAVE(I)=digital_val		!SAVE FOR NEXT RUN
C
400	CONTINUE
C
	TOT(1)=0
	TOT(2)=0
	DRUMSF(1)=0
	DRUMSF(2)=0
C
	DO 500	I=1,10		!SUM 5 STREAMS FOR EACH LINE
		J=((I-1)/5)+1	!1=LINE 6...2=LINE 7
		K=(GROUP(I)*10)+I	!STREAM WITHIN GROUP
		TOT(J)=TOT(J)+NEWVAL(K)	!ACCUM FOR ENTIRE LINE
C
C	BUILD A BIT PATTERN OF DRUMS THAT ARE FEEDING THE 32 BELT NOW
C	INCLUDING SECONDS OF REMAINING 31 BELT TRAVEL
C
		L=MOD(I-1,5)
		K=((GROUP(I)+6)*10)+I
		IF (NEWVAL(K) .GT. 30) THEN
			CONTRL(J)=JIBSET(CONTRL(J),L+12)
			DRUMSF(J)=DRUMSF(J)+1
		ELSE
			CONTRL(J)=JIBCLR(CONTRL(J),L+12)
		END IF
C

500	CONTINUE
C
	status = SHC_get_digital_val_stat(B32(1), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF LINE 6 32 BELT RUNNING
C
	IF (digital_val .EQ. 1) THEN		!SHUFFLE TABLE AND INSERT TONS
		DO 600 I=127,1,-1
			TOTL(I+1)=TOTL(I)
600		CONTINUE
		TOTL(1)=TOT(1)		!PUSH NEW L6 TONS TO TOP
	END IF
C
	status = SHC_get_digital_val_stat(B32(2), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF LINE 7 32 BELT RUNNING
C
	IF (digital_val .EQ. 1) THEN		!SHUFFLE TABLE AND INSERT TONS
		DO 700 I=255,129,-1
			TOTL(I+1)=TOTL(I)
700		CONTINUE
		TOTL(129)=TOT(2)	!PUSH NEW L7 TONS TO TOP
	END IF
C
C
	ANVAL(STUFF(1))=TOT(1)		!PUT LINE 6 IN ANVAL
	ANVAL(STUFF(2))=TOT(2)		!PUT LINE 7 IN ANVAL
	ANVAL(STUFF(3))=DRUMSF(1)	!DRUMS FEEDING LINE 6
	ANVAL(STUFF(4))=DRUMSF(2)	!DRUMS FEEDING LINE 7
	M=(STUFF(1)/32)+1
	N=MOD(STUFF(1),32)
	GPT(M)=JIBSET(GPT(M),N)		!SET GOODPT LINE 6 32 BELT TONS
	GPT(M)=JIBSET(GPT(M),N+1)	!SET GOODPT LINE 7 32 BELT TONS
	GPT(M)=JIBSET(GPT(M),N+2)	!SET GOODPT LINE 6 DRUMS FEEDING
	GPT(M)=JIBSET(GPT(M),N+3)	!SET GOODPT LINE 7 DRUMS FEEDING
C
	DO 800 I=1,2
		SPDL32(I)=SPDN32(I)	!SAVE 32 BELT SPD LAST SCAN
		SPDN32(I)=SPD32(I)	!NEW 32 BELT SPEED
800	CONTINUE
C
	DO 2000 I=1,2
C
C	CALCULATE THE 2 SEC TONNAGE AT THE GRATE NOW
C	INCLUDING 10 SECONDS OF ROLL FEEDER TIME
C	AND 4 SECS OF REMAINING 31 BELT TRAVEL
C
		IF (SPDN32(I) .LE. 0)THEN
			J=0		!AVOID DIV BY ZERO
			GOTO 820
		END IF
C
C
		J=(INCH32/SPDN32(I))*30
C
820		CONTINUE
C
C	ADD SECONDS OF EXCESS 31 BELT TRAVEL AND ROLL FEEDER TIME
C
		J=J+5			!REMAINING TRAVEL TIME
		IF (J .GT. 128)J=128	!CHECK INDEX
		J=J+((I-1)*128)		!GET TO RIGHT TABLE
C
		LTPH(I)=TOTL(J)
C
		ACCUM=0
		OBS=0
C
		CNTLSP(I)=BEDSP(I)	!GET CONTROLLER SETPOINT
		CALL CHKGPT(BEDSPX(I),BIT)	!CHECK GOODPOINT
		IF (BIT .NE. 1) THEN
			PRGLSP(I)=CRTLSP(I)
		ELSE
			PRGLSP(I)=CNTLSP(I)
		END IF
C
		LVLPRO(I)=LVLPRN(I)	!SAVE OLD BED LVL
		LVLPRN(I)=BEDLVL(I)	!NEW BED LEVEL
C
		SPDPRO(I)=SPDPRN(I)	!SAVE OLD GRATE SPEED
		SPDPRN(I)=SPDG(I)	!NEW GRATE SPEED
C
		status = SHC_get_digital_val_stat(BCTLCX(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF 32 BELT ON COMP
C
		IF (digital_val .EQ. 1) THEN
			CONTRL(I)=JIBCLR(CONTRL(I),1)	!ON COMP
		ELSE
			CONTRL(I)=JIBSET(CONTRL(I),1)	!OFF COMP
		END IF
C
		status = SHC_get_digital_val_stat(CTRLCX(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF GRATE ON COMP
C
		IF (digital_val .EQ. 1) THEN
			CONTRL(I)=JIBCLR(CONTRL(I),0)	!ON COMP
		ELSE 
			CONTRL(I)=JIBSET(CONTRL(I),0)	!OFF COMP
			OUTPUT(I)=CSPDG(I)
			OUTBAS(I)=CSPDG(I)
			IF (LTPH(I) .EQ. 0)LTPH(I)=500
			LVOBAS(I)=(PRGLSP(I)/LTPH(I))*SPDPRN(I)
			LVLOUT(I)=(PRGLSP(I)/LTPH(I))*SPDPRN(I)
			GOTO 1000
		END IF
C
		status = SHC_get_digital_val_stat(GRATCX(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF GRATE ON COMP
C
		IF (digital_val .EQ. 0)GOTO 1000	!GRATE IS OFF
C
C	CALCULATE CONTRIBUTION OF LEVEL ERROR TO SPEED AS FEEDBACK
C
		TEMP=LVLPRN(I)-PRGLSP(I)
C		IF ((TEMP .GE. -0.3).AND.(TEMP .LE. 0.3))TEMP=0
		CHECK=(TEMP*LVSPI(I))+LVOBAS(I)
		CALL HILO(CHECK,LVLHI(I),LVLLO(I))
		LVOBAS(I)=CHECK
C
		TEMP=TEMP*LVSPP(I)
		CHECK=((LVLPRO(I)-LVLPRN(I))*LVSPD(I))+TEMP+LVOBAS(I)
		CALL HILO(CHECK,LVLHI(I),LVLLO(I))
		LVLOUT(I)=CHECK
C
C	CALCULATE SPEED SETPOINT
C
		SPDSET(I)=(LTPH(I)*LVLOUT(I))/PRGLSP(I)
C
C	SPEED SETPOINT TO OUTPUT IS STANDARD PID
C
		TEMP=SPDSET(I)-SPDPRN(I)
		CHECK=(TEMP*SPOUTI(I))+OUTBAS(I)
		CALL HILO(CHECK,SPDHI(I),SPDLO(I))
		OUTBAS(I)=CHECK
		TEMP=TEMP*SPOUTP(I)
		CHECK=((SPDPRO(I)-SPDPRN(I))*SPOUTD(I))+TEMP+OUTBAS(I)
		CALL HILO(CHECK,SPDHI(I),SPDLO(I))
		OUTPUT(I)=CHECK
C
C
C	LOCATE CURRENT COMBINATION OF DRUMS AND
C	GET APPROPRIATE SETPOINT
C
1000		CONTINUE
		TEMPX=JIBITS(CONTRL(I),12,5)
		DO 1100 L=1,32
			IF (TEMPX .EQ. L-1)THEN
				IF (I .EQ. 1)THEN
					SPDS32(I)=SET326(L)
				ELSE
					SPDS32(I)=SET327(L)
				END IF
				GOTO 1200
			END IF
1100		CONTINUE
C
1200		CONTINUE
C
		BIT=JIBITS(CONTRL(I),1,1)	!ARE WE ON 32B CONTROL
		IF (BIT .EQ. 1)THEN
			SPDB32(I)=CSPD32(I)	!USE CONTROLLER OUTPUT
			SPDO32(I)=CSPD32(I)	!FOR BASE AND OUTPUT
			GOTO 2000
		END IF
C
C	DO 32 BELT SPEED PID
C
		TEMP=SPDS32(I)-SPDN32(I)
		CHECK=(TEMP*OUT32I(I))+SPDB32(I)
		CALL HILO(CHECK,SP32HI(I),SP32LO(I))
		SPDB32(I)=CHECK
		TEMP=TEMP*OUT32P(I)
		CHECK=((SPDL32(I)-SPDN32(I))*OUT32D(I))+TEMP+SPDB32(I)
		CALL HILO(CHECK,SP32HI(I),SP32LO(I))
		SPDO32(I)=CHECK
C
2000	CONTINUE
C
C	MAKE ALL PROCESS OUTPUTS (1 DO AND 4 AO'S)
C
	DO 2100	I=1,28
C
		TIMEOUT=IIBITS(AS(I),15,1)	!EXTRACT TIMED OUT BIT
C
		IF (TIMEOUT .EQ. 1)THEN		!IF ANY POINT IS TIMED OUT
C
			CALL	LIB$DATE_TIME(DATETIME)
C
			OPEN	(UNIT=22,FILE='CTL:GRATE3.ERR',
	1		STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
			WRITE	(22,78)DATETIME
78			FORMAT	(' TIMED OUT POINTS DETECTED   ',A)
C
			CLOSE	(UNIT=22)
C
	   		GO TO 3000
C
		END IF
C
2100	CONTINUE
C
	IF (put_digital_val .EQ. 1)THEN	!PERFORM COMP ACKNOW USING DO
		put_digital_val=0	!IF RELAY IS OPEN THEN CLOSE IT
	ELSE
		put_digital_val=1	!IF RELAY IS CLOSED THEN OPEN IT
	END IF
C
	status = SHC_put_point_quality(DO, point_quality)
	status = SHC_put_digital_val( DO, put_digital_val)
C
	put_analog_val=OUTPUT(1)		!LINE 6 GRATE SPEED
	status = SHC_put_point_quality(AO(1), point_quality)
	status = SHC_put_analog_val(AO(1), put_analog_val)
C
	put_analog_val=OUTPUT(2)		!LINE 7 GRATE SPEED
	status = SHC_put_point_quality(AO(2), point_quality)
	status = SHC_put_analog_val(AO(2), put_analog_val)
C
	put_analog_val=SPDO32(1)	!LINE 6 32 BELT SPEED
	status = SHC_put_point_quality(AO(3), point_quality)
	status = SHC_put_analog_val(AO(3), put_analog_val)
C
	put_analog_val=SPDO32(2)	!LINE 7 32 BELT SPEED
	status = SHC_put_point_quality(AO(4), point_quality)
	status = SHC_put_analog_val(AO(4), put_analog_val)
C
3000	CONTINUE
	CALL	SYS$HIBER()
	GOTO 100
C
99999	CONTINUE
C
	CALL	EXIT
C
	END
C
	SUBROUTINE	CHKGPT(POINT,BIT)
C
C	SUBROUTINE WILL RETURN GOODPT STATUS OF SELECTED ANALOG
C
	INTEGER*4	BIT,POINT,I,J,GPT(40)
C
	COMMON/AG3_GOODPTTBL/GPT
C
	I=(POINT/32)+1		!WORD IN TABLE
	J=MOD(POINT,32)		!BIT IN WORD
	BIT=JIBITS(GPT(I),J,1)	!EXTRACT BIT
	RETURN
	END
C
	SUBROUTINE	HILO(VALUE,HI,LO)
C
C	SUBROUTINE WILL DO HI/LO LIMIT CHECKING FOR CALCULATED VALUES
C
	REAL*4		VALUE,HI,LO
C
	IF (VALUE .GT. HI)VALUE=HI
	IF (VALUE .LT. LO)VALUE=LO
	RETURN
	END
