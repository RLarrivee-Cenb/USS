CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C	CONFIDENTIAL
C	Property of United States Steel Corporation
C	Copyright 2013 United States Steel Corporation
C	All rights reserved.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 	IMPLICIT INTEGER (A-Z)
C
C Program revisions:
C
c	8-26-04  changed out-of-spec parameter from calcium to
c	(calcium+magnesium)/silica per Sarrah E Mattila (process engineer)
C
C	20090401 IM528776 JOH8811 Temporarily, due to layoffs, send the
C		Agg3 filter cake sio2 value to the ANA:FCAKE.DAT file.
C                  
C	20090811 IM575560 JOH8811 Back out all changes from IM528776.
C
C	20130116 IM1224302 SPA6635 Changed sio2 and ba upper/lower limits
C
	EXTERNAL UFO_OPEN
C
c
C
	REAL XUP,XDOWN,RUP,RDOWN,BAV
C
C 
C
	INTEGER  WORKSPACE( 3 ),	!General workspace
	1	 CHECKWKSP( 3 ),	!Check workspace
	2	 TCA( 3 ),		!Terminal Control Area
    	3	 GASN_FORM(500),	!Storage for memory resident form
    	4	 GASD_FORM(750) 	!Storage for memory resident form
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCC
	STRUCTURE /DATA/
C
	CHARACTER LABEL*40
C
	REAL YAXB
	REAL YAXE
	REAL YAXRB
	REAL YAXRE
C
	REAL XVAL(43)
	REAL RVAL(43)
C
	INTEGER DTM(2,43)
C
	REAL XBAR
	REAL UCL
	REAL LCL
	REAL STDV
C
	REAL RBAR
	REAL UCLR
	REAL LCLR
	REAL STDVR
C
	INTEGER CSH
C
	INTEGER CODE(42)
	INTEGER RCODE(42)
C
	REAL 	TARGET
	REAL	USL
	REAL	LSL
C
C
	END STRUCTURE
C
C
	RECORD /DATA/TB(1)
C
C 
	REAL XB(2),UC(2),LC(2),RB(2),UR(2),TA(2),US(2),LS(2)
C
C
	CHARACTER ASC*2,AHR*5,ADATE*23,ADATX*23,AA*9,A2*2,H2*5/'0 02:'/,
	1	MON(12)*3/'JAN','FEB','MAR','APR','MAY','JUN','JUL',
	1	'AUG','SEP','OCT','NOV','DEC'/,AONE /'1'/,KY*8,ADS*23
C                   
	INTEGER BTIM(2),BH2(2),TIMX(2),CHECK(2),BINT(2)
C
	INTEGER II,IDATE(2),BONE(2),BDATE(2),LDAY(2)
C
	REAL BA,R,PF
C
	STRUCTURE /VALUES/
C
		CHARACTER 	KEY*8	!YYYYMMDD
c
		INTEGER 	HOUR		!1-12
C
		REAL		SIL(12),AL(12),CA(12),MG(12)
C
		INTEGER		TIME(2,12)
C
	END STRUCTURE
C
	RECORD /VALUES/ DAT,D2,DATZ
C
C
C
C
	CHARACTER ASDATE*11,KL*4,QED*23,ABX*3
C
C
	LOGICAL NEWDATA
C
	REAL CAX(172),SUM4,GMIN,GMAX
	INTEGER CTIME(2,172)
C
	CHARACTER STM*23
C
	INTEGER CALCIUM_OK,CALCIUM2,CALCIUM3
C
	CALL SYS$BINTIM (H2,BH2)	!convert 2 hours to binary
	CALL SYS$BINTIM (AONE,BONE)
C
C
C
C
C
464	CALL FDV$ATERM( %DESCR(TCA),12 ,2,,,)
	CALL FDV$AWKSP( %DESCR(WORKSPACE), 2000 )
	CALL FDV$LOPEN( 'DISK0:[FLUX]FLUX',1)
C
	CALL FDV$SPON ()
	CALL FDV$CDISP ('FLUX')
C
	CALL FDV$PUT ('3','STEP')
C
C
C
c	  indexed file in DESCENDING order.
c
61	OPEN (UNIT=10,FILE='USER7:[FLUX]SLURRY33.DAT',
	1	STATUS='OLD',ACCESS='KEYED',
	2	SHARED)
C
	IBB=0
C
300	READ (10,IOSTAT=MMM) DAT
C
	IF (MMM .EQ. 52) THEN
		IBB=IBB+1
		IF (IBB .GE. 10) GO TO 3833
		CALL LIB$WAIT (1.)
		GO TO 300
	END IF
C
	IF (MMM .NE. 0) THEN
C
3833		CALL FDV$PUTL ('NO RECORDS AVAILABLE')
		CALL LIB$WAIT (2.)
		GO TO 99
C
	END IF
C
		READ (DAT.KEY(5:6),'(I2)') II
C
		ADATE=DAT.KEY(7:8)//'-'//MON(II)//'-'//DAT.KEY(1:4)
C
	IF (DAT.HOUR .GE. 12) THEN
C
		READ (DAT.KEY(5:6),'(I2)') II
C
		ADATE=DAT.KEY(7:8)//'-'//MON(II)//'-'//DAT.KEY(1:4)
		CALL SYS$BINTIM (ADATE,BDATE)
		CALL LIB$ADD_TIMES (BDATE,BONE,BDATE)
		CALL SYS$ASCTIM (,ADATE,BDATE,)
		IF (ADATE(1:1) .EQ. ' ') ADATE(1:1)='0'
C
		DO 320 I=1,12
			IF (MON(I) .EQ. ADATE(4:6)) GO TO 321
320		CONTINUE
C
		STOP ' B.O. MONTH'
C
321		WRITE (KY(5:6),'(I2)')I
		IF (KY(5:5) .EQ. ' ') KY(5:5)='0'
		KY=ADATE(8:11)//KY(5:6)//ADATE(1:2)
C
C
		IBB=0
5682		READ (10,KEY=KY,IOSTAT=MMM) DAT
C
C
			IF (MMM .EQ. 52) THEN
			IBB=IBB+1
			IF (IBB .GE. 20) GO TO 2833
			CALL LIB$WAIT (1.)
			GO TO 5682
			END IF
C
		IF (.NOT.(MMM .EQ. 0 .OR. MMM .EQ. 36)) THEN
C
2833			CALL FDV$PUTL ('UNABLE TO MAKE NEW RECORD,CALL 7490')
			CALL LIB$WAIT (20.)
			GO TO 99
C
		END IF
C
C
C
C
		DAT=DATZ
C
		DAT.HOUR=0
		DAT.KEY=KY
	END IF
C
C
C
C
	DAT.HOUR=DAT.HOUR+1
C
C
	JJ=(DAT.HOUR-1)*2+1
C
	JH=JJ
C
	WRITE (ADATE(13:14),'(I2)') JJ
C
C
117	CALL FDV$PUT (ADATE(1:2)//ADATE(4:6)//ADATE(10:11),'DATE')
	CALL FDV$PUT (Adate(13:14),'TIME')
C
	ADS=ADATE
C
	BYPASS=0
C
C
119	CALL FDV$GET (AA,TERM,'TDREPLY')
C
	IBY=0
C
C
C
C
C
C
	NEWDATA=.TRUE.
C
	IF ((AA .EQ. 'N').or.(aa .eq. 'n')) THEN
		NEWDATA=.FALSE. !DATA IS OLD
318		CALL FDV$SPOFF ()
		CALL FDV$GET (ADATE,TERM,'DATE')
		ABX='-20'
		IF (ADATE(6:7) .GT. '67') ABX='-19'
		ADATE(1:11)=ADATE(1:2)//'-'//ADATE(3:5)//ABX//ADATE(6:7)
		CALL FDV$GET (ADATE(13:14),TERM,'TIME')
C
C
		IF (ADATE(14:14) .EQ. ' ')ADATE(13:14)='0'//ADATE(13:13)
		IF (ADATE(13:13) .EQ. ' ')ADATE(13:13)='0'
	IF ((ADATE(13:14).LT.'00').OR.(ADATE(13:14).GT.'23'))GO TO 318
		ADATE(15:23)='         '
C		
		CALL SYS$BINTIM (ADATE,TIMX)
		READ(ADATE(13:14),'(I2)') IBY
		JH=IBY
		IBY=(IBY+1)/2
C
C
C	   read either new record or requested old record
C
	DAT.KEY(1:4)=ADATE(8:11)
C
	DO 18 I=1,12
		IF (ADATE(4:6) .EQ. MON(I))  GO TO 1918
18	CONTINUE
C
	CALL FDV$PUTL (' THE DATE OR TIME IS INVALID, PLEASE REVISE')
		CALL LIB$WAIT (3.0)
	GO TO 119
C
1918	WRITE (DAT.KEY(5:6),'(I2)') I
	IF (DAT.KEY(5:5) .EQ. ' ') DAT.KEY(5:5)='0'
C
	IF (ADATE(1:1) .EQ. ' ')ADATE(1:1)='0'
	DAT.KEY(7:8)=ADATE(1:2)
C
	IF (ADATE(13:13) .EQ. ' ')ADATE(13:13)='0'
C
C
1919	READ (10,KEY=DAT.KEY,IOSTAT=MMM) DAT
C
C
	IF (MMM .EQ. 52) GO TO 1919
C
	IF (MMM .NE. 0 .OR. IBY .GT. DAT.HOUR) THEN
C
	CALL FDV$PUTL ('YOU ASKED FOR A DATE-TIME THAT DOES NOT EXIST')
	CALL LIB$WAIT (2.)
	GO TO 99
C
	END IF
C
C
	CALL FDV$PUT (ADATE(1:2)//ADATE(4:6)//ADATE(10:11),'DATE')
	CALL FDV$PUT (Adate(13:14),'TIME')
C
C
	END IF
C
C
C
C
C
C
	IF (IBY .GT. 0) THEN
		INDEX=IBY
	ELSE
		INDEX=DAT.HOUR
C
c		  save input time
c
		CALL SYS$GETTIM (DAT.TIME(1,INDEX))
C
	END IF
C
C
575		IF (DAT.SIL(INDEX) .LE. 0 .OR. DAT.AL(INDEX) .LE. 0
	1.OR. DAT.CA(INDEX) .LE. 0 .OR. DAT.MG(INDEX) .LE. 0) GO TO 303
C
		WRITE (AA,'(BN,F4.2)',ERR=71) DAT.SIL(INDEX)
		CALL FDV$PUT (AA,'SIL')
71 		WRITE (AA,'(BN,F3.2)',ERR=72) DAT.AL(INDEX)
		CALL FDV$PUT (AA,'AL')
72 		WRITE (AA,'(BN,F4.2)',ERR=73) DAT.CA(INDEX)
		CALL FDV$PUT (AA,'CA')
73		WRITE (AA,'(BN,F4.2)',ERR=303) DAT.MG(INDEX)
		CALL FDV$PUT (AA,'MG')
C
C 
C
C
303	CALL FDV$GET (AA,IT,'SIL')
C
	READ (AA,'(F4.0)',ERR=171) DAT.SIL(INDEX)
C
C
171	CALL FDV$GET (AA,IT,'AL')
C
	READ (AA,'(F3.0)',ERR=172) DAT.AL(INDEX)
C
172	CALL FDV$GET (AA,IT,'CA')
C
	READ (AA,'(F4.0)',ERR=173) DAT.CA(INDEX)
C
C
173	CALL FDV$GET (AA,IT,'MG')
C
	READ (AA,'(F4.0)',ERR=174) DAT.MG(INDEX)
C
C
174	IF ((dat.AL(INDEX)+dat.SIL(INDEX)) .LE. 0)GO TO 774
C
	BA=(dat.CA(INDEX)+dat.MG(INDEX))/(dat.AL(INDEX)+dat.SIL(INDEX))
C
 	PF=((dat.CA(INDEX)+dat.MG(INDEX))-.6)/.5377
	R=(PF/(100-PF))
C
	write (aa,'(f5.2)',err=773) ba
	call fdv$put (aa,'base')
c
773	write (aa,'(f5.4)',err=774) R
	CALL FDV$PUT (AA,'RATIO')
c
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C	IM1224302
774	MMSIL=0	  
	IF ((DAT.SIL(INDEX) .LT. 3.78)
	1	.OR.(DAT.SIL(INDEX) .GT. 4.35)) MMSIL=1
C
	IF (dat.AL(INDEX)+dat.SIL(INDEX) .LE. 0) GO TO 223
	BA=(dat.CA(INDEX)+dat.MG(INDEX))/(dat.AL(INDEX)+dat.SIL(INDEX))
C
	MMBA=0	  
	IF ((BA .LT. 0.92) .OR. (BA.GT. 1.28)) MMBA=1
C
C
	IF (BYPASS .GE. 1) GO TO 223
	BYPASS=1
C
	IF (MMSIL .GT. 0 .AND. MMBA .GT. 0) THEN
C
		CALL FDV$cDISP ('BOTHOUT')
		CALL FDV$GET (AA,IT,'REPLY')
		call fdv$dISP ('flux')
	CALL FDV$PUT (ADATE(1:2)//ADATE(4:6)//ADATE(10:11),'DATE')
	CALL FDV$PUT (Adate(13:14),'TIME')
	write (aa,'(f5.2)',err=3773) ba
	call fdv$put (aa,'base')
c
3773	write (aa,'(f5.4)',err=575) R
	CALL FDV$PUT (AA,'RATIO')
		GO TO 575
C
	ELSE IF (MMSIL .GT. 0 .AND. MMBA .LE. 0) THEN
C
		CALL FDV$cDISP ('SILOUT3')
		CALL FDV$GET (AA,IT,'REPLY')
		call fdv$dISP ('flux')
	CALL FDV$PUT (ADATE(1:2)//ADATE(4:6)//ADATE(10:11),'DATE')
	CALL FDV$PUT (Adate(13:14),'TIME')
	write (aa,'(f5.2)',err=4773) ba
	call fdv$put (aa,'base')
c
4773	write (aa,'(f5.4)',err=575) R
	CALL FDV$PUT (AA,'RATIO')
		GO TO 575
C	
	ELSE IF (MMSIL .LE. 0 .AND. MMBA .GT. 0) THEN
C
		CALL FDV$cDISP ('BAOUT3')
		CALL FDV$GET (AA,IT,'REPLY')
		call fdv$dISP ('flux')
	CALL FDV$PUT (ADATE(1:2)//ADATE(4:6)//ADATE(10:11),'DATE')
	CALL FDV$PUT (Adate(13:14),'TIME')
	write (aa,'(f5.2)',err=5773) ba
	call fdv$put (aa,'base')
c
5773	write (aa,'(f5.4)',err=575) R
	CALL FDV$PUT (AA,'RATIO')
		GO TO 575
C	
	END IF
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
223	CALL FDV$GET (AA,IT,'REPLY')
	IF ((AA(1:1) .EQ. 'Y').OR.(AA(1:1) .EQ. 'y')) go to 992 
	IF ((AA(1:1) .EQ. 'n').OR.(AA(1:1) .EQ. 'N')) THEN
		BYPASS=0
		go to 575
	END IF
C
C
C
C
C
99	CALL FDV$LCLOS
	CALL FDV$SPADA (0)
	CALL FDV$DWKSP (%DESCR(WORKSPACE))
	CALL FDV$DTERM(%DESCR(TCA))
	GO TO 500
C
c
C
992	CA=DAT.CA(INDEX)
	MG=DAT.MG(INDEX)
	AL=DAT.AL(INDEX)
	SIL=DAT.SIL(INDEX)
C
	IF (MMM .EQ. 36) then
C
		WRITE (10) DAT
		CLOSE (10)
c
cccccccccccccccccccccccccccccc
c
c	log input time to a file
c
	CALL SYS$ASCTIM (,STM,,)
	OPEN (UNIT=28,FILE='USER_D:[FLUX]ITIME.TXT',STATUS='UNKNOWN',
	1access='append',ERR=556)
	WRITE (28,2828,ERR=556) '3',ADS(1:11),ADS(13:14),STM
2828	FORMAT (' ',A,1X,A11,1X,A2,':00',1X,A)
	CLOSE (28)
cccccccccccccccccccccccccccccc
c
	ELSE IF (MMM .EQ. 0) THEN
C
		REWRITE (10) DAT
		CLOSE (10)
cccccccccccccccccccccccccccccc
c
c	log input time to a file
c
	CALL SYS$ASCTIM (,STM,,)
	OPEN (UNIT=28,FILE='USER_D:[FLUX]ITIME.TXT',STATUS='UNKNOWN',
	1access='append',ERR=556)
	WRITE (28,2828,ERR=556) '3',ADS(1:11),ADS(13:14),STM
	CLOSE (28)
cccccccccccccccccccccccccccccc
C
	ELSE 
		CALL FDV$PUTL ('DATA DID NOT WRITE BACK CALL 7490')
		CALL FDV$WAIT ()
	END IF
C
C
C                              
C
C
C
556	OPEN (UNIT=11,FILE='USER_D:[FLUX]LIVESLURRY.DAT',
	1	STATUS='UNKNOWN',
	1	FORM='UNFORMATTED'
	2	,SHARED,USEROPEN=UFO_OPEN)
C
	REWIND (11)
C
	WRITE (11) CA,MG,AL,SIL,JH
C
	CLOSE (11)                 
C
	CALL FDV$LCLOS
	CALL FDV$SPADA (0)
	CALL FDV$DWKSP (%DESCR(WORKSPACE))
	CALL FDV$DTERM(%DESCR(TCA))
C
C
C
	IF (.not. newdata) go to 500	!old date requested, don't increase
C					!input count
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C	FIND OUT-OF-SPEC DATA AND SEND TO FILE AND TURN ON CALCIUM 
C	OUT OF SPEC SPC CHART
C
C
C
C
	CALCIUM_OK=1	!SET TO 1, RESET TO 0 IF ANY POINTS OUT OF SPEC
C			!THIS VALUE IS SENT TO [RJM]RATIO FOR TRACKING
C			!FLUX RATIO SETTINGS.
C
C
333	OPEN (UNIT=10,FILE='user_d:[flux]SLURRY33.DAT',
	1	STATUS='OLD',ACCESS='KEYED',SHARED,ERR=1919)
C
C
CCC
C	  read latest record
C
	READ (10,IOSTAT=MM) DAT
C
C
	READ (DAT.KEY(5:6),'(I2)') MG
	ASDATE=DAT.KEY(7:8)//'-'//MON(MG)//'-'//DAT.KEY(1:4)
C
C
	IVAL=43
C
	IF (ASDATE(1:1) .EQ. ' ') ASDATE(1:1)='0'
C
	CALL SYS$BINTIM (ASDATE,BINT)
	GO TO 404
C
C
C
111	CALL SYS$ASCTIM (,ASDATE,BINT,)
C
	IF (ASDATE(1:1) .EQ. ' ') ASDATE(1:1)='0'
C
	DO 9344 I=1,12
		IF (MON(I) .EQ. ASDATE(4:6)) GO TO 45
9344	CONTINUE
	STOP
C
45	WRITE (KY(5:6), '(I2)') I
	IF (KY(5:5) .EQ. ' ') KY(5:5)='0'
C
	KY=ASDATE(8:11)//KY(5:6)//ASDATE(1:2)
C
C
	K4=0
C
244	READ (10,KEY=KY,IOSTAT=MM) DAT
C
	IF (MM .EQ. 52) THEN
		CALL LIB$WAIT (1.)
		K4=K4+1
		IF (K4 .GE. 20) THEN
		CALL SYS$ASCTIM (,QED,,)
		OPEN (86,FILE='USER_D:[FLUX]ERRORS3.LIS',STATUS='UNKNOWN',
	1		ACCESS='APPEND')
		WRITE (86,862) QED,KY,MM
		CLOSE (86)
862	FORMAT (1H ,'FILE BUSY ',A,2X,A,2X,I4)
			 STOP
		END IF
		GO TO 244
	ELSE IF (MM .EQ. 36) THEN
		go to 444		!record non-exists, get previous day
	ELSE IF (MM .EQ. 0) THEN
		GO TO 404
	ELSE
		CALL SYS$ASCTIM (,QED,,)
		OPEN (86,FILE='USER_D:[FLUX]ERRORS3.LIS',STATUS='UNKNOWN',
	1		ACCESS='APPEND')
		WRITE (86,861) QED,KY,MM
		CLOSE (86)
861	FORMAT (1H ,'DIFF. ERROR ',A,2X,A,2X,I4)
C
	END IF
C
CCCCCCCCCC
C
C
C
404	INDEX=DAT.HOUR
C
454	WRITE (A2,'(I2)') (INDEX-1)*2+1
C
	read (dat.key(5:6),'(i2)') L
c
	asdate=dat.key(7:8)//'-'//mon(L)//'-'//DAT.KEY(1:4)//' '//
	1	A2//':00'
C
	CALL SYS$BINTIM (ASDATE,LDAY)
C
C
C
C
CCCCC	IF (DAT.CA(INDEX) .LE. 0) GO TO 6300
CCCCC	TB(1).XVAL(IVAL)=DAT.CA(INDEX)
C 
	BAV=0
	IF (DAT.SIL(INDEX) .GT. 0) 
	1  BAV=(DAT.CA(INDEX)+DAT.MG(INDEX))/DAT.SIL(INDEX)
C
	IF (BAV .LE. 0) GO TO 6300
	TB(1).XVAL(IVAL)=BAV
 	TB(1).DTM(1,IVAL)=LDAY(1)
	TB(1).DTM(2,IVAL)=LDAY(2)
C
	IVAL=IVAL-1
6300	INDEX=INDEX-1
	IF (IVAL .LE. 0) GO TO 4293
	IF (INDEX .LE. 0) GO TO 444
C
	GO TO 454
C
444	CALL LIB$SUB_TIMES (BINT,BONE,BINT)
	GO TO 111
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
4293	DO 38 I=43,2,-1
38	TB(1).RVAL(I)=ABS(TB(1).XVAL(I)-TB(1).XVAL(I-1))
C
C
	DO 383 I=2,43
		TB(1).XVAL(I-1)=TB(1).XVAL(I)
		TB(1).RVAL(I-1)=TB(1).RVAL(I)
		TB(1).DTM(1,I-1)=TB(1).DTM(1,I)
		TB(1).DTM(2,I-1)=TB(1).DTM(2,I)
383	CONTINUE
C
C
C
C
	OPEN (UNIT=10,FILE='USER_D:[FLUX]CALCIUM_LIMITS.DAT',
	1	STATUS='UNKNOWN',FORM='UNFORMATTED',RECL=100)
C	1	,USEROPEN=UFO_OPEN,SHARED)
C
	READ (10)XB,UC,LC,RB,UR,TA,US,LS
C
	CLOSE (10)
C
	TB(1).xbar=xb(2)
	TB(1).UCL=UC(2)
	TB(1).LCL=LC(2)
	TB(1).RBAR=RB(2)
	TB(1).UCLR=UR(2)
	TB(1).TARGET=TA(2)
	TB(1).USL=US(2)
	TB(1).LSL=LS(2)
C
C
	DO 9455 JK=1,42
		TB(1).CODE(JK)=0
		TB(1).RCODE(JK)=0
9455	CONTINUE
C
C
C
	KL='S3CA'
C
C
C
	L=1
C
C	   get last 42 out of spec points for this graph
C
C
	DO 641 LL=42,1,-1
C
	IF (TB(L).XVAL(LL) .LE. 0) GO TO 641
C
		CODE=0
		RCODE=0
C
		IF (TB(L).XVAL(LL) .GT. TB(L).UCL) THEN
 		CODE=1
			IF (LL .EQ. 42) THEN
				CALL CHECKOUT (KL)
				CALCIUM_OK=0
			END IF
		END IF
C
C
		IF (TB(L).XVAL(LL) .LT. TB(L).LCL) THEN
		CODE=2
			IF (LL .EQ. 42) THEN
				CALL CHECKOUT (KL)
				CALCIUM_OK=0
			END IF
		END IF
C
C
		IF (TB(L).RVAL(LL) .GT. TB(L).UCLR) THEN
		RCODE=4
			IF (LL .EQ. 42) THEN
				CALL CHECKOUT (KL)
			END IF
		END IF
C
	IF (CODE .NE. 0) THEN
		TB(L).CODE(LL)=CODE
	END IF
	IF (RCODE .NE. 0) THEN
		TB(L).RCODE(LL)=RCODE
	END IF
C
641	CONTINUE
C
C
C
C
C
C
C
C
	LABOVE=0
	LBELOW=0
	LRABOVE=0
	LRBELOW=0
	LXUP=0
	LXDOWN=0
	LRUP=0
	LRDOWN=0
	XUP=0
	XDOWN=0
	RUP=0
	RDOWN=0
	CODE=0
	RCODE=0
C
	DO 651 LL=1,42
C
	IF (TB(L).XVAL(LL) .LE. 0) GO TO 651
C
		IF (TB(L).XVAL(LL) .GT. TB(L).XBAR) THEN
			LABOVE=LABOVE+1
			IF (LABOVE .GE. 11) THEN
				TB(L).CODE(LL)=3
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE
			LABOVE=0
		END IF
C
C
C
		IF (TB(L).XVAL(LL) .LT. TB(L).XBAR) THEN
			LBELOW=LBELOW+1
			IF (LBELOW .GE. 11) THEN
				TB(L).CODE(LL)=11
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE  
			LBELOW=0
		END IF
C
C
		IF (TB(L).RVAL(LL) .LT. TB(L).RBAR) THEN
			LRBELOW=LRBELOW+1
			IF (LRBELOW .GE. 13) THEN
				TB(L).RCODE(LL)=5
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE
			LRBELOW=0
		END IF
C
C
		IF (TB(L).RVAL(LL) .GT. TB(L).RBAR) THEN
			LRABOVE=LRABOVE+1
			IF (LRABOVE .GE. 7) THEN
				TB(L).RCODE(LL)=6
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE
			LRABOVE=0
		END IF
C
C
CCCCCCCCCCC
C
C		check for 7 ascending x values
C
		IF (XUP .EQ. 0) THEN
			XUP=TB(L).XVAL(LL)
			GO TO 922
		END IF
C
		IF (TB(L).XVAL(LL) .GT. XUP) THEN
			XUP=TB(L).XVAL(LL)
			LXUP=LXUP+1
			IF (LXUP .GE. 7) THEN
				TB(L).CODE(LL)=7
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE
			XUP=0
			LXUP=0
		END IF
CCCCCCCCCCC
C
C		check for 7 descending x values
C
922		IF (XDOWN .EQ. 0) THEN
			XDOWN=TB(L).XVAL(LL)
			GO TO 923
		END IF
C
		IF (TB(L).XVAL(LL) .LT. XDOWN) THEN
			XDOWN=TB(L).XVAL(LL)
			LXDOWN=LXDOWN+1
			IF (LXDOWN .GE. 7) THEN 
				TB(L).CODE(LL)=8
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE
			XDOWN=0
			LXDOWN=0
		END IF
C
C
CCCCCCCCCCC
C
C		check for 7 ascending R values
C
923		IF (RUP .EQ. 0) THEN
			RUP=TB(L).RVAL(LL)
			GO TO 924
		END IF
C
		IF (TB(L).RVAL(LL) .GT. RUP) THEN
			RUP=TB(L).RVAL(LL)
			LRUP=LRUP+1
			IF (LRUP .GE. 7) THEN
				TB(L).RCODE(LL)=9
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE
			RUP=0
			LRUP=0
		END IF
C
C
CCCCCCCCCCC
C
C		check for 7 descending R values
C
924		IF (RDOWN .EQ. 0) THEN
			RDOWN=TB(L).RVAL(LL)
			LRDOWN=0
			GO TO 651
		END IF
C
		IF (TB(L).RVAL(LL) .LT. RDOWN) THEN
			RDOWN=TB(L).RVAL(LL)
			LRDOWN=LRDOWN+1
			IF (LRDOWN .GE. 7) THEN
				TB(L).RCODE(LL)=10
				IF (LL .EQ. 42) THEN
					CALL CHECKOUT (KL)
				END IF
			END IF
		ELSE
			RDOWN=0
			LRDOWN=0
		END IF
C
C
C
C
C
651	CONTINUE
C
C
	OPEN (UNIT=44,FILE='USER_D:[FLUX]CAL3.DAT',
	1	STATUS='UNKNOWN',ACCESS='DIRECT',FORM='UNFORMATTED',
	1	RECL=1000,SHARED)
C
	WRITE (44,REC=1) TB(1)
C
C
C
CCCCCCCC
C
C	SEND STATUS OF LAST CALCIUM READING TO A FILE SO [RJM]RATIO.EXE
C	CAN SEE IT.
C
CC162	OPEN (37,FILE='USER_D:[RJM]CALCIUM_STATUS.DAT',STATUS='OLD',
CC	1	ERR=262)
C
CC	GO TO 263
CC262	CALL LIB$WAIT (1.)
CC	GO TO 162
C
CC263	REWIND (37)
CC	READ (37,373,ERR=462) CALCIUM2,CALCIUM3
CC373	FORMAT (2I1)
C
CC	CALCIUM3=CALCIUM_OK
C
CC	REWIND (37)
CC788	WRITE (37,373,ERR=463) CALCIUM2,CALCIUM3
C
CC	CLOSE (37)
CC	GO TO 500
C
CC462	CALL LIB$WAIT (1.)
CC	GO TO 263
CC463	CALL LIB$WAIT (1.)
CC	GO TO 788
CCCCCCCC
C
500	STOP
	END
C
C
C
C
C
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
	SUBROUTINE CHECKOUT (KEY)
C
C
	CHARACTER KEY*4
	INTEGER ID(2),IS,IH,CODE,IDX,IDY
C
C
C
	STRUCTURE /HOSER/
C
		CHARACTER ID*4		! (L3BT,L7AT,S2BA,S3H2...)
		INTEGER	  DATE(2)
		INTEGER	  SHIFT
		INTEGER   HALF
		REAL	  VALUE		! X or R value if applicable
		INTEGER   CODE		! 1= x hi  2= x lo  3= 7 x-values above
c					! or below mean.  4= r hi  5= 13 r
c					! values below rbar  6= 7 r values above
c					! rbar.  7= 7 ascending x values  8=
c					! 7 descending x values.
c					! 9= 7 ascending r values.  10= 7
C					! descending r values.
		 
C
	END STRUCTURE
c
	RECORD /HOSER/ OUT
C
C
	L=17
	IF (L .EQ. 0) GO TO 15
C
	L=16
C
c	  contains data to send to xxxxxxxxxxxx so it can be printed
c	  on a corrective action report.
C
15	OPEN (UNIT=34,FILE='USER_D:[METREP.GKS]LIVE_OUT_OF_SPEC.DAT',
	1	STATUS='OLD',ACCESS='KEYED',SHARED)
C
C
	READ (34,KEY=KEY,IOSTAT=MX) OUT
C
	IF (MX .EQ. 0) GO TO 292
		OUT.ID=KEY
C
	WRITE (34) OUT
292	CLOSE (34)
	RETURN
	END
