C
	PROGRAM GRATECTL	!REVISED TO SMOOTH TONS
C
C	(GRATE CONTROL)
C
C	THIS PROGRAM RUNS EVERY 2 SECONDS AND CONTROLS THE SPEED
C	OF THIS GRATE DRIVE AND THE 032 BELT FOR LINES 4 & 5 AGGL
C
C
C	REVISION 04-08-2005 032 BELT SPEED LINE 4 FOR 5 DRUMS HAS BEEN
C	SET TO 358 IPM PER PETE PRIJATEL.
C
C	REVISION 04-11-2005 032 BELT SPEED LINE 5 FOR 5 DRUMS HAS BEEN
C	SET TO 270 IPM PER PETE PRIJATEL.
C
C	REVISION 08-12-2005 MODIFY 032 BELT CONTROL FOR LINES 4 AND 5
C	DELAY 60 SECONDS BEFORE INCREASING THE SPEED SETPOINT WHENEVER ADDING
C	OR DROPPING A BALLING DRUM STREAM PER BILL SIMONSON
C
C	REVISION 02-01-2006 032 BELT SPEED LINE 4 FOR 5 DRUMS HAS BEEN
C	SET TO 307 IPM PER BILL SIMONSON.
C
C	REVISION 02-16-2006 CHANGE TIMER TO 36 SECONDS FOR LINES 4 AND 5
C	032 BELT CONTROL BEFORE INCREASING THE SPEED SETPOINT WHENEVER ADDING
C	OR DROPPING A BALLING DRUM STREAM PER CHAD STEWART
C
C	REVISION 02-07-2007 032 BELT SPEED LINE 5 FOR 5 DRUMS HAS BEEN
C	SET TO 235 IPM PER CLIFF ERICKSON SERVICE CENTER TICKET PM617506
C
C	REVISION 02-16-2007 032 BELT SPEED LINE 4 FOR 5 DRUMS HAS BEEN
C	SET TO 275 IPM PER CLIFF ERICKSON SERVICE CENTER TICKET PM622523
C
C	REVISION 03-02-2007 032 BELT SPEED LINE 4 FOR 5 DRUMS HAS BEEN
C	SET TO 300 IPM PER CLIFF ERICKSON SERVICE CENTER TICKET PM630119
C
C	REVISION 10-11-2010 032 BELT SPEED LINE 5 FOR 5 DRUMS HAS BEEN
C	SET TO 260 IPM PER BILL SIMONSON SERVICE CENTER TICKET IM735984
C
C	REVISION 12-17-2010 032 BELT SPEED LINE 5 FOR 5 DRUMS HAS BEEN
C	SET TO 236 IPM PER BILL SIMONSON SERVICE CENTER TICKET IM762011
C
	IMPLICIT NONE
C
C	LINK GRATECTL,GRATECTL/OPT,WESAPI_LIB:WESAPI/OPT
C
	INCLUDE 'WESAPI:SPD.DCL'
	INCLUDE 'WESAPI:SHC_defines.DCL'
	INCLUDE 'WESAPI:SHC_err.DCL'
C
	INTEGER*4	LIB$SYS_TRNLOG
	INTEGER*4 	status
	CHARACTER*20	highway

	CHARACTER*40    spd_filename
	INTEGER*2	spd_filename_len
	INTEGER*2	spd_fd
	INTEGER*2	access_type
	INTEGER*2	c_short_val
	CHARACTER*2	field_name
	CHARACTER*8	pt_name
	BYTE		extended_flag
	BYTE		gp_bit_num
	BYTE		inactive_flag
	BYTE		c_byte_val
	INTEGER*4	gp_sid
	INTEGER*2       get_pkd_group_val
	INTEGER*2       get_pkd_group_stat
	INTEGER*2       gp_force_stat
	INTEGER*2       gp_op_mask
	INTEGER*2       gp_val_mask
	INTEGER*2	AS(32)
	BYTE		gp_bitnum 
	INTEGER*2	digital_val
	INTEGER*2	digital_stat
	INTEGER*2	TIMEOUT
C
	REAL            put_analog_val
	INTEGER*2	PUT_DIGITAL_VAL
C
	INTEGER*4	LEN,POINT_QUALITY
C
	CHARACTER*8	TIME/'0 0:0:02'/
	CHARACTER*23	DATETIME
C
	REAL*4		VALU(32)
	REAL*4		TIMEX,
	1		PM24/86400.0/,
	1		TEMP,
	1		CHECK,
	1		INCH32/216/,
	1		TOT(2),
	1		DRUMSF(2),
	1		LTH6(10),
	1		LTH7(10),
	1		ACCUM,
	1		OBS
C
	INTEGER*4	CADO,GSPD4,GSPD5,SPD324,SPD325,LTPH4,LTPH5
C
	INTEGER*4	STIMER(2)
	REAL*4		LSPDS32(2),TSPDS32(2)
C
	INTEGER*4	CONTRL(2)
	REAL*4		PRGLSP(2),
	1		LVLPRN(2),
	1		LVOBAS(2),
	1		LVLOUT(2),
	1		SPDSET(2),
	1		SPDPRN(2),
	1		OUTBAS(2),
	1		OUTPUT(2),
	1		SPDO32(2),
	1		LTPH(2),
	1		LVSPI(2),
	1		LVSPD(2),
	1		LVSPP(2),
	1		SPOUTI(2),
	1		SPOUTD(2),
	1		SPOUTP(2),
	1		LVLHI(2),
	1		LVLLO(2),
	1		SPDHI(2),
	1		SPDLO(2),
	1		CNTLSP(2),
	1		CRTLSP(2),
	1		LVLPRO(2),
	1		SPDPRO(2),
	1		SPDS32(2),
	1		SPDN32(2),
	1		SPDL32(2),
	1		SPDB32(2),
	1		OUT32I(2),
	1		OUT32D(2),
	1		OUT32P(2),
	1		SP32LO(2),
	1		SP32HI(2)
	REAL*4		SET326(32)/250,250,250,250,250,250,250,275,
	1		           250,250,250,280,250,255,274,250,
	1		           250,250,250,255,250,255,272,275,
	1			   250,320,265,250,260,260,260,300/
	REAL*4		SET327(32)/250,250,250,250,250,250,250,255,
	1			   250,250,250,240,250,240,245,244,
	1			   250,250,250,245,250,245,230,244,
	1		           250,240,240,258,248,248,255,236/
C
	REAL*4		ANVAL(1200),
	1		NEWVAL(300),
	1		TOTL(256),
	1		FORTIM(10)
C
	INTEGER*4	TEMPX,UFO_OPEN
	INTEGER*4	CXSAVE(10),
	1		GPT(50)
	INTEGER*4	I,J,K,L,M,N,ADDRESS(2),BIT
	INTEGER*4	GBBELT(10)
	INTEGER*4	BDRUM(10)
	INTEGER*4	GBFR(10)
	INTEGER*4	GROUP(10)/5,4,10,11,35,
	1			  9,6,7,10,14/
	INTEGER*4	STUFF(4)/1036,1037,1038,1039/
	INTEGER*4	B32(2)
	INTEGER*4	GBSCLEX(10)/67,68,69,70,71,
	1		            183,184,185,186,187/
	INTEGER*4	BEDSPX(2)/575,609/,
	1		CTRLCX(2),
	1		BCTLCX(2),
	1		GRATCX(2)
	INTEGER*4	AO(6),DO(1),AI(32)
C
	REAL*4		SKIP,
	1		GBSCLE(10),
	1		B27(10),
	1		BEDSP(2),
	1		BEDLVL(2),
	1		SPD32(2),
	1		SPDG(2),
	1		CSPDG(2),
	1		CSPD32(2)
C
	CHARACTER*8	GBBELTP(10)/'DA603214','DA603230',
	1			    'DA603246','DA603262',
	1			    'DA601151','DA605149',
	1			    'DA605165','DA605181',
	1			    'DA605197','DA602117'/
C
	CHARACTER*8	BDRUMP(10)/'DI603349','DI603365',
	1			   'DI603381','DI603397',
	1			   'DI601269','DI605355',
	1			   'DI605371','DI605387',
	1			   'DI605403','DI602285'/
C
	CHARACTER*8	GBFRP(10)/'DF603084','DF603092',
	1			  'DF603100','DF603108',
	1			  'DF601036','DF605083',
	1			  'DF605092','DF605100',
	1			  'DF605108','DF602036'/
C
	CHARACTER*8	B32P(2)/'DI601179','DA602189'/
C
	CHARACTER*8	BCTLCXP(2)/'DL603108','DL605103'/
C
	CHARACTER*8	CTRLCXP(2)/'DL603107','DL605102'/
C
	CHARACTER*8	GRATCXP(2)/'DI601364','DI602314'/
C
	CHARACTER*8	AOP(6)/'AD600014','AD600015','AD600016',
	1		       'AD600017','AD600039','AD600040'/
C
	CHARACTER*8	DOP/'DD600006'/
C
	CHARACTER*8	AIP(32)/'AI603000','AI603006','AI601012','AI603012',
	1			'AI601013','AI605000','AI605006','AI605012',
	1			'AI605018','AI605017','AI603001','AI603007',
	1			'AI603030','AI603031','AI603032','AI605001',
	1			'AI605007','AI605013','AI605036','AI605037',
	1			'SP603589','SP605709','AS603024','AS605024',
	1			'AI601024','AI602036','AI603026','AI605026',
	1			'AO603010','AO605005','AO603011','AO605003'/
C
	COMMON/ANVALTBL/ANVAL
	COMMON/GRATETBL/NEWVAL,TOTL,FORTIM,CXSAVE
	COMMON/GRATEFILE/CONTRL,PRGLSP,LVLPRN,LVOBAS,
	1		 LVLOUT,SPDSET,SPDPRN,OUTBAS,
	1		 OUTPUT,SPDO32,LTPH,LVSPI,
	1		 LVSPD,LVSPP,SPOUTI,SPOUTD,
	1		 SPOUTP,LVLHI,LVLLO,SPDHI,
	1		 SPDLO,CNTLSP,CRTLSP,LVLPRO,
	1		 SPDPRO,SPDS32,SPDN32,SPDL32,
	1		 SPDB32,OUT32I,OUT32D,OUT32P,
	1		 SP32LO,SP32HI
C
	COMMON/GOODPTTBL/GPT
C
	EQUIVALENCE	(VALU(1),GBSCLE(1))
	EQUIVALENCE	(VALU(2),GBSCLE(2))
	EQUIVALENCE	(VALU(3),GBSCLE(3))
	EQUIVALENCE	(VALU(4),GBSCLE(4))
	EQUIVALENCE	(VALU(5),GBSCLE(5))
	EQUIVALENCE	(VALU(6),GBSCLE(6))
	EQUIVALENCE	(VALU(7),GBSCLE(7))
	EQUIVALENCE	(VALU(8),GBSCLE(8))
	EQUIVALENCE	(VALU(9),GBSCLE(9))
	EQUIVALENCE	(VALU(10),GBSCLE(10))
	EQUIVALENCE	(VALU(11),B27(1))
	EQUIVALENCE	(VALU(12),B27(2))
	EQUIVALENCE	(VALU(13),B27(3))
	EQUIVALENCE	(VALU(14),B27(4))
	EQUIVALENCE	(VALU(15),B27(5))
	EQUIVALENCE	(VALU(16),B27(6))
	EQUIVALENCE	(VALU(17),B27(7))
	EQUIVALENCE	(VALU(18),B27(8))
	EQUIVALENCE	(VALU(19),B27(9))
	EQUIVALENCE	(VALU(20),B27(10))
	EQUIVALENCE	(VALU(21),BEDSP(1))
	EQUIVALENCE	(VALU(22),BEDSP(2))
	EQUIVALENCE	(VALU(23),BEDLVL(1))
	EQUIVALENCE	(VALU(24),BEDLVL(2))
	EQUIVALENCE	(VALU(25),SPD32(1))
	EQUIVALENCE	(VALU(26),SPD32(2))
	EQUIVALENCE	(VALU(27),SPDG(1))
	EQUIVALENCE	(VALU(28),SPDG(2))
	EQUIVALENCE	(VALU(29),CSPDG(1))
	EQUIVALENCE	(VALU(30),CSPDG(2))
	EQUIVALENCE	(VALU(31),CSPD32(1))
	EQUIVALENCE	(VALU(32),CSPD32(2))
C
	EXTERNAL	UFO_OPEN
C
5	CONTINUE
C
C	OPEN CONNECTION TO AGGL 1-2 POINT DIRECTORY
C
        status = LIB$SYS_TRNLOG('WESAPI_PDIR_0',
     1			spd_filename_len,spd_filename,,,)
C
	spd_filename(spd_filename_len+1:) = CHAR(0)
C
        access_type = RUNTIME
C
        spd_fd = SPD_open_file(%ref(spd_filename), access_type)
C
	DO 20	J=1,6	!GET THE 6 AGGL 1-2 ANALOG OUTPUT SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(AOP(J)//char(0)),AO(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
20	CONTINUE
C
C                   GET COMPUTER ACKNOWLEDGE DO SID
C
	        status = SPD_get_sid(spd_fd,%ref(DOP//char(0)),DO,
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
	DO 30	J=1,32	!GET THE 32 AGGL 1-2 PROCESS VARIABLES SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(AIP(J)//char(0)),AI(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
30	CONTINUE
C
	DO 31	J=1,10	!GET THE 10 AGGL 1-2 GREEN BALL BELT CX SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(GBBELTP(J)//char(0)),
	1			GBBELT(J),
     x		            gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
31	CONTINUE
C
	DO 32	J=1,10	!GET THE 10 AGGL 1-2 GREEN BALL FORWARD CX SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(GBFRP(J)//char(0)),GBFR(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
32	CONTINUE
C
	DO 33	J=1,10	!GET THE 10 AGGL 1-2 BALLING DRUM CX SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(BDRUMP(J)//char(0)),BDRUM(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
33	CONTINUE
C
	DO 34	J=1,2	!GET THE 2 AGGL 1-2 32 BELT CX SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(B32P(J)//char(0)),B32(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
34	CONTINUE
C
	DO 35	J=1,2	!GET THE 2 AGGL 1-2 32 BELT COMP CX SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(BCTLCXP(J)//char(0)),
	1			BCTLCX(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
35	CONTINUE
C
	DO 36	J=1,2	!GET THE 2 AGGL 1-2 GRATE CX SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(GRATCXP(J)//char(0)),
	1			GRATCX(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
36	CONTINUE
C
	DO 37	J=1,2	!GET THE 2 AGGL 1-2 GRATE COMP CX SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(CTRLCXP(J)//char(0)),
	1			CTRLCX(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
37	CONTINUE
C
C  Close the point directory connection
C
	status = SPD_close_file(spd_fd)
C
C  Open the connection to SHC memory for WESAPI access
	status = SHC_open_memory()
C
	IF (status .NE. SHC_OK) THEN
		IF (status .EQ. SHC_E_MEMOPEN)GOTO 88
C
		OPEN	(UNIT=22,FILE='CTL:GRATE.ERR',STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
		WRITE	(22,77)status
77		FORMAT	(' SHC open memory failure - error =',I4)
C
		CLOSE	(UNIT=22)
C
	   GO TO 99999
C
	ENDIF
C
88	CONTINUE
C
	OPEN	(UNIT=1,FILE='CTL:GRATE.DAT',STATUS='NEW',
	1	RECL=68,ACCESS='DIRECT',RECORDTYPE='FIXED',
	1	FORM='UNFORMATTED',SHARED,USEROPEN=UFO_OPEN)
C
	READ	(1,REC=1)CONTRL,PRGLSP,LVLPRN,LVOBAS,
	1		 LVLOUT,SPDSET,SPDPRN,OUTBAS,
	1		 OUTPUT,SPDO32,LTPH,LVSPI,
	1		 LVSPD,LVSPP,SPOUTI,SPOUTD,
	1		 SPOUTP,LVLHI,LVLLO,SPDHI,
	1		 SPDLO,CNTLSP,CRTLSP,LVLPRO,
	1		 SPDPRO,SPDS32,SPDN32,SPDL32,
	1		 SPDB32,OUT32I,OUT32D,OUT32P,
	1		 SP32LO,SP32HI
C
	CLOSE	(UNIT=1)
C
	CALL	SYS$BINTIM(TIME,ADDRESS)
	CALL	SYS$SCHDWK(,,ADDRESS,ADDRESS)
C
100	CONTINUE
C
	DO 150	I=1,32	!READ IN THE 32 PROCESS VALUES NEEDED FOR THIS PASS
C
		status = SHC_get_analog_val_stat( AI(I), valu(I), AS(I))
C
150	CONTINUE
C
	DO 300	I=290,1,-1
		NEWVAL(I+10)=NEWVAL(I)	!SHUFFLE DOWN STREAM BLOCK
300	CONTINUE
C
	DO 400	I=1,10
C
		status = SHC_get_digital_val_stat(GBBELT(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat)
C
		IF (digital_val .EQ. 0)GOTO 340	!30 BELT OFF GO HERE
C
		status = SHC_get_digital_val_stat(BDRUM(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat)
C
		IF (digital_val .EQ. 0)GOTO 350	!BALL DRUM OFF GO HERE
C
		status = SHC_get_digital_val_stat(GBFR(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat)
C
		IF (digital_val .EQ. 0)GOTO 340	!30 BELT IN REV GO HERE
C
		BIT=digital_val
c
		TIMEX=SECNDS(0.0)	!GRAB TIME IN SECONDS
		IF ((BIT-CXSAVE(I)) .NE. 0) THEN
			FORTIM(I)=TIMEX	!BELT CHANGED TO FORWARD
			GOTO 350	!THIS SCAN ...SAVE TIME
		END IF
C
		IF ((TIMEX-FORTIM(I)) .LT. 0) TIMEX=TIMEX+PM24
C
		IF ((TIMEX-FORTIM(I)-30.0) .GT. 0)THEN	!IF MORE THAN 30 SEC
			NEWVAL(I)=GBSCLE(I)	!AGO GB SCALE OK
			GOTO 355
		END IF
C
		CALL	CHKGPT(GBSCLEX(I),BIT)	!CHECK GPT ON SCALE
		IF (BIT .EQ. 1) THEN	!IF READING IS GOOD USE IT
			NEWVAL(I)=GBSCLE(I)
			GOTO 355
		END IF
C
		IF ((TIMEX-FORTIM(I)-5.0) .LT. 0)GOTO 350!LESS THAN 5 SEC 
C
		TEMP=B27(I)	!OTHERWISE USE 27 BELT TONS
		TEMP=TEMP*2		!DOUBLE THEM
		NEWVAL(I)=TEMP
		GOTO 355
C
340		CONTINUE
C
		IF (I .EQ. 6)THEN	!IF THIS IS 5-1 STREAM
			NEWVAL(I+10)=0
			NEWVAL(I+20)=0
			NEWVAL(I+30)=0
			NEWVAL(I+40)=0
			NEWVAL(I+50)=0
		ELSE    		!FOR ALL OTHER STREAMS
			NEWVAL(I+10)=0
			NEWVAL(I+20)=0
			NEWVAL(I+30)=0
		END IF
C
350		CONTINUE
		NEWVAL(I)=0.0			!ZERO TONS THIS BELT
355		CONTINUE
C
		status = SHC_get_digital_val_stat(GBFR(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat)
C
		CXSAVE(I)=digital_val			!FOR NEXT RUN
C
400	CONTINUE
C
	TOT(1)=0
	TOT(2)=0
	DRUMSF(1)=0
	DRUMSF(2)=0
C
	DO 500	I=1,10		!SUM 5 STREAMS FOR EACH LINE
		J=((I-1)/5)+1	!1=LINE 4...2=LINE 5
		K=(GROUP(I)/2)*10+I	!STREAM WITHIN GROUP
		TOT(J)=TOT(J)+NEWVAL(K)	!ACCUM FOR ENTIRE LINE
C
C	BUILD A BIT PATTERN OF DRUMS THAT ARE FEEDING THE 32 BELT NOW
C	INCLUDING 4 SECS OF REMAINING 31 BELT TRAVEL
C
		L=MOD(I-1,5)
		K=((GROUP(I)+4)/2)*10+I
		IF (NEWVAL(K) .GT. 30) THEN
			CONTRL(J)=JIBSET(CONTRL(J),L+12)
			DRUMSF(J)=DRUMSF(J)+1
		ELSE
			CONTRL(J)=JIBCLR(CONTRL(J),L+12)
		END IF
C

500	CONTINUE
C
	status = SHC_get_digital_val_stat(B32(1), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF LINE 4 32 BELT RUNNING
C
	IF (digital_val .EQ. 1) THEN		!SHUFFLE TABLE AND INSERT TONS
		DO 600 I=127,1,-1
			TOTL(I+1)=TOTL(I)
600		CONTINUE
		TOTL(1)=TOT(1)		!PUSH NEW L4 TONS TO TOP
	END IF
C
	status = SHC_get_digital_val_stat(B32(2), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF LINE 5 32 BELT RUNNING
C
	IF (digital_val .EQ. 1) THEN		!SHUFFLE TABLE AND INSERT TONS
		DO 700 I=255,129,-1
			TOTL(I+1)=TOTL(I)
700		CONTINUE
		TOTL(129)=TOT(2)	!PUSH NEW L5 TONS TO TOP
	END IF
C
C
	ANVAL(STUFF(1))=TOT(1)		!PUT LINE 4 IN ANVAL
	ANVAL(STUFF(2))=TOT(2)		!PUT LINE 5 IN ANVAL
	ANVAL(STUFF(3))=DRUMSF(1)	!DRUMS FEEDING LINE 4
	ANVAL(STUFF(4))=DRUMSF(2)	!DRUMS FEEDING LINE 5
	M=(STUFF(1)/32)+1
	N=MOD(STUFF(1),32)
	GPT(M)=JIBSET(GPT(M),N)		!SET GOODPT LINE 4 32 BELT TONS
	GPT(M)=JIBSET(GPT(M),N+1)	!SET GOODPT LINE 5 32 BELT TONS
	GPT(M)=JIBSET(GPT(M),N+2)	!SET GOODPT LINE 4 DRUMS FEEDING
	GPT(M)=JIBSET(GPT(M),N+3)	!SET GOODPT LINE 5 DRUMS FEEDING
C
	DO 800 I=1,2
		SPDL32(I)=SPDN32(I)	!SAVE 32 BELT SPD LAST SCAN
		SPDN32(I)=SPD32(I)	!NEW 32 BELT SPEED
800	CONTINUE
C
	DO 2000 I=1,2
C
C	CALCULATE THE 2 SEC TONNAGE AT THE GRATE NOW
C	INCLUDING 10 SECONDS OF ROLL FEEDER TIME
C	AND 4 SECS OF REMAINING 31 BELT TRAVEL
C
		IF (SPDN32(I) .LE. 0)THEN
			J=0		!AVOID DIV BY ZERO
			GOTO 820
		END IF
C
C
		J=(INCH32/SPDN32(I))*30
C		J=20	!RUN WITH FIXED 32 BELT TIME OF 40 SEC
C
820		CONTINUE
C
C	ADD 5 SEC OF EXCESS 31 BELT TRAVEL AND 7.5 SEC OF ROLL FEEDER TIME
C
C		J=J+6			!REMAINING TRAVEL TIME
		J=J+3			!REMAINING TRAVEL TIME
		IF (J .GT. 128)J=128	!CHECK INDEX
		J=J+((I-1)*128)		!GET TO RIGHT TABLE
C
		LTPH(I)=TOTL(J)
C
		ACCUM=0
		OBS=0
C
		IF (I .EQ. 1)THEN
			DO 830 N=9,1,-1
				LTH6(N+1)=LTH6(N)	!SHIFT L6 TONS
830			CONTINUE
			LTH6(1)=TOTL(J)
			DO 840 N=1,10
				IF (LTH6(N) .NE. 0)THEN
					ACCUM=ACCUM+LTH6(N)
					OBS=OBS+1
				END IF
840			CONTINUE
			IF (OBS .NE. 0)THEN
C				LTPH(I)=ACCUM/OBS	!SMOOTHED TONS
			ELSE
C				LTPH(I)=0
			END IF
C
		ELSE
			DO 850 N=9,1,-1
				LTH7(N+1)=LTH7(N)	!SHIFT L7 TONS
850			CONTINUE
			LTH7(1)=TOTL(J)
			DO 860 N=1,10
				IF (LTH7(N) .NE. 0)THEN
					ACCUM=ACCUM+LTH7(N)
					OBS=OBS+1
				END IF
860			CONTINUE
			IF (OBS .NE. 0)THEN
C				LTPH(I)=ACCUM/OBS	!SMOOTHED TONS
			ELSE
C				LTPH(I)=0
			END IF
		END IF
C
		CNTLSP(I)=BEDSP(I)	!GET CONTROLLER SETPOINT
		CALL CHKGPT(BEDSPX(I),BIT)	!CHECK GOODPOINT
		IF (BIT .NE. 1) THEN
			PRGLSP(I)=CRTLSP(I)
		ELSE
			PRGLSP(I)=CNTLSP(I)
		END IF
C
		LVLPRO(I)=LVLPRN(I)	!SAVE OLD BED LVL
		LVLPRN(I)=BEDLVL(I)	!NEW BED LEVEL
C
		SPDPRO(I)=SPDPRN(I)	!SAVE OLD GRATE SPEED
		SPDPRN(I)=SPDG(I)	!NEW GRATE SPEED
C
		status = SHC_get_digital_val_stat(BCTLCX(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF 32 BELT ON COMP
C
		IF (digital_val .EQ. 1) THEN
			CONTRL(I)=JIBCLR(CONTRL(I),1)	!ON COMP
		ELSE
			CONTRL(I)=JIBSET(CONTRL(I),1)	!OFF COMP
		END IF
C
		status = SHC_get_digital_val_stat(CTRLCX(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF GRATE ON COMP
C
		IF (digital_val .EQ. 1) THEN
			CONTRL(I)=JIBCLR(CONTRL(I),0)	!ON COMP
		ELSE 
			CONTRL(I)=JIBSET(CONTRL(I),0)	!OFF COMP
			OUTPUT(I)=CSPDG(I)
			OUTBAS(I)=CSPDG(I)
			IF (LTPH(I) .EQ. 0)LTPH(I)=500
			LVOBAS(I)=(PRGLSP(I)/LTPH(I))*SPDPRN(I)
			LVLOUT(I)=(PRGLSP(I)/LTPH(I))*SPDPRN(I)
			GOTO 1000
		END IF
C
		status = SHC_get_digital_val_stat(GRATCX(I), gp_sid, gp_bitnum,
	1	digital_val, digital_stat) !SEE IF GRATE ON COMP
C
		IF (digital_val .EQ. 0)GOTO 1000	!GRATE IS OFF
C
C	CALCULATE CONTRIBUTION OF LEVEL ERROR TO SPEED AS FEEDBACK
C
		TEMP=LVLPRN(I)-PRGLSP(I)
		IF ((TEMP .GE. -0.3).AND.(TEMP .LE. 0.3))TEMP=0
		CHECK=(TEMP*LVSPI(I))+LVOBAS(I)
		CALL HILO(CHECK,LVLHI(I),LVLLO(I))
		LVOBAS(I)=CHECK
C
		TEMP=TEMP*LVSPP(I)
		CHECK=((LVLPRO(I)-LVLPRN(I))*LVSPD(I))+TEMP+LVOBAS(I)
		CALL HILO(CHECK,LVLHI(I),LVLLO(I))
		LVLOUT(I)=CHECK
C
C	CALCULATE SPEED SETPOINT
C
		SPDSET(I)=(LTPH(I)*LVLOUT(I))/PRGLSP(I)
C
C	SPEED SETPOINT TO OUTPUT IS STANDARD PID
C
		TEMP=SPDSET(I)-SPDPRN(I)
		CHECK=(TEMP*SPOUTI(I))+OUTBAS(I)
		CALL HILO(CHECK,SPDHI(I),SPDLO(I))
		OUTBAS(I)=CHECK
		TEMP=TEMP*SPOUTP(I)
		CHECK=((SPDPRO(I)-SPDPRN(I))*SPOUTD(I))+TEMP+OUTBAS(I)
		CALL HILO(CHECK,SPDHI(I),SPDLO(I))
		OUTPUT(I)=CHECK
C
C
C	LOCATE CURRENT COMBINATION OF DRUMS AND
C	GET APPROPRIATE SETPOINT
C
1000		CONTINUE
		LSPDS32(I)=SPDS32(I)	!SAVE CURRENT SPEED SETPOINT
C
		TEMPX=JIBITS(CONTRL(I),12,5)
		DO 1100 L=1,32
			IF (TEMPX .EQ. L-1)THEN
				IF (I .EQ. 1)THEN
C					SPDS32(I)=SET326(L)
				       TSPDS32(I)=SET326(L)
				ELSE
C				        SPDS32(I)=SET327(L)
				       TSPDS32(I)=SET327(L)
				END IF
				GOTO 1200
			END IF
1100		CONTINUE
C
1200		CONTINUE
C
		IF (STIMER(I) .EQ. 0)THEN
		IF (TSPDS32(I) .LE. LSPDS32(I))THEN
			SPDS32(I)=TSPDS32(I)	!IF SPEED NOT INCREASING
			GOTO 1222		!CHANGE SETPOINT IMMDEIATELY
		ELSE	
			STIMER(I)=STIMER(I)+1	!DON'T CHANGE SETPOINT
			GOTO 1222
		END IF
		ELSE
			STIMER(I)=STIMER(I)+1	!BUMP RUN COUNT
			IF (STIMER(I) .GE. 18)THEN
				SPDS32(I)=TSPDS32(I)	!TIME TO CHANGE
				STIMER(I)=0
			END IF
		END IF
C
1222		CONTINUE
C
		BIT=JIBITS(CONTRL(I),1,1)	!ARE WE ON 32B CONTROL
		IF (BIT .EQ. 1)THEN
			SPDB32(I)=CSPD32(I)	!USE CONTROLLER OUTPUT
			SPDO32(I)=CSPD32(I)	!FOR BASE AND OUTPUT
			GOTO 2000
		END IF
C
C	DO 32 BELT SPEED PID
C
		TEMP=SPDS32(I)-SPDN32(I)
		CHECK=(TEMP*OUT32I(I))+SPDB32(I)
		CALL HILO(CHECK,SP32HI(I),SP32LO(I))
		SPDB32(I)=CHECK
		TEMP=TEMP*OUT32P(I)
		CHECK=((SPDL32(I)-SPDN32(I))*OUT32D(I))+TEMP+SPDB32(I)
		CALL HILO(CHECK,SP32HI(I),SP32LO(I))
		SPDO32(I)=CHECK
C
2000	CONTINUE
C
C	MAKE ALL PROCESS OUTPUTS (1 DO AND 4 AO'S)
C
	DO 2100	I=1,28
C
		TIMEOUT=IIBITS(AS(I),15,1)	!EXTRACT TIMED OUT BIT
C
		IF (TIMEOUT .EQ. 1)THEN		!IF ANY POINT IS TIMED OUT
C
			CALL	LIB$DATE_TIME(DATETIME)
C
			OPEN	(UNIT=22,FILE='CTL:GRATE.ERR',
	1		STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
			WRITE	(22,78)DATETIME
78			FORMAT	(' TIMED OUT POINTS DETECTED   ',A)
C
			CLOSE	(UNIT=22)
C
	   		GO TO 3000
C
		END IF
C
2100	CONTINUE
C
	IF (put_digital_val .EQ. 1)THEN	!PERFORM COMP ACKNOW USING DO
		put_digital_val=0	!IF RELAY IS OPEN THEN CLOSE IT
	ELSE
		put_digital_val=1	!IF RELAY IS CLOSED THEN OPEN IT
	END IF
C
	status = SHC_put_point_quality(DO, point_quality)
	status = SHC_put_digital_val( DO, put_digital_val)
C
	put_analog_val=OUTPUT(1)		!LINE 4 GRATE SPEED
	status = SHC_put_point_quality(AO(1), point_quality)
	status = SHC_put_analog_val(AO(1), put_analog_val)
C
	put_analog_val=OUTPUT(2)		!LINE 5 GRATE SPEED
	status = SHC_put_point_quality(AO(2), point_quality)
	status = SHC_put_analog_val(AO(2), put_analog_val)
C
	put_analog_val=SPDO32(1)	!LINE 4 32 BELT SPEED
	status = SHC_put_point_quality(AO(3), point_quality)
	status = SHC_put_analog_val(AO(3), put_analog_val)
C
	put_analog_val=SPDO32(2)	!LINE 5 32 BELT SPEED
	status = SHC_put_point_quality(AO(4), point_quality)
	status = SHC_put_analog_val(AO(4), put_analog_val)
C
	put_analog_val=LTPH(1)		!LINE 4 TONS AT GRATE
	status = SHC_put_point_quality(AO(5), point_quality)
	status = SHC_put_analog_val(AO(5), put_analog_val)
C
	put_analog_val=LTPH(2)		!LINE 5 TONS AT GRATE
	status = SHC_put_point_quality(AO(6), point_quality)
	status = SHC_put_analog_val(AO(6), put_analog_val)
C
3000	CONTINUE
	CALL	SYS$HIBER()
	GOTO 100
C
99999	CONTINUE
C
	CALL	EXIT
C
	END
C
	SUBROUTINE	CHKGPT(POINT,BIT)
C
C	SUBROUTINE WILL RETURN GOODPT STATUS OF SELECTED ANALOG
C
	INTEGER*4	BIT,POINT,I,J,GPT(50)
C
	COMMON/GOODPTTBL/GPT
C
	I=(POINT/32)+1		!WORD IN TABLE
	J=MOD(POINT,32)		!BIT IN WORD
	BIT=JIBITS(GPT(I),J,1)	!EXTRACT BIT
	RETURN
	END
C
	SUBROUTINE	HILO(VALUE,HI,LO)
C
C	SUBROUTINE WILL DO HI/LO LIMIT CHECKING FOR CALCULATED VALUES
C
	REAL*4		VALUE,HI,LO
C
	IF (VALUE .GT. HI)VALUE=HI
	IF (VALUE .LT. LO)VALUE=LO
	RETURN
	END
