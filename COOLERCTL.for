C
	PROGRAM COOLERCTL
C
C	(COOLER CONTROL)
C
C	THIS PROGRAM RUNS EVERY 2 SECONDS AND CONTROLS THE SPEED
C	OF THE COOLER DRIVE FOR LINES 3,4 & 5 AGGL
C
C	LINK COOLERCTL,COOLERTCTL/OPT,WESAPI_LIB:WESAPI/OPT
C
	IMPLICIT NONE
C
	INCLUDE 'WESAPI:SPD.DCL'
	INCLUDE 'WESAPI:SHC_defines.DCL'
	INCLUDE 'WESAPI:SHC_err.DCL'
C
	INTEGER*4	LIB$SYS_TRNLOG
	INTEGER*4 	status
	CHARACTER*20	highway

	CHARACTER*40    spd_filename
	INTEGER*2	spd_filename_len
	INTEGER*2	spd_fd
	INTEGER*2	access_type
	INTEGER*2	c_short_val
	CHARACTER*2	field_name
	CHARACTER*8	pt_name
	BYTE		extended_flag
	BYTE		gp_bit_num
	BYTE		inactive_flag
	BYTE		c_byte_val
	INTEGER*4	gp_sid
	INTEGER*2       get_pkd_group_val
	INTEGER*2       get_pkd_group_stat
	INTEGER*2       gp_force_stat
	INTEGER*2       gp_op_mask
	INTEGER*2       gp_val_mask
	INTEGER*2	AS(32)
	BYTE		gp_bitnum 
	INTEGER*2	digital_val
	INTEGER*2	digital_stat
	INTEGER*2	TIMEOUT
C
	REAL            put_analog_val
	INTEGER*2	PUT_DIGITAL_VAL
	REAL*4		VALU(15)
C
	INTEGER*4	LEN,POINT_QUALITY
C
	CHARACTER*8	TIME/'0 0:0:02'/
	CHARACTER*23	DATETIME
C
	INTEGER*4	GOOD(3)
	INTEGER*4	GPT(50),TIMERX(3),FTIMER(3),BAD(3)
	REAL*4		TEMP,CHECK,LAST(3)
	REAL*4		LFAIL(3)/0.95,0.95,0.95/
C
	INTEGER*4	CONTRL(3)
	INTEGER*4	AO(3),DO(4),AI(15),DI(6)
C
	REAL*4		PRGLSP(3),
	1		LVLPRN(3),
	1		LVOBAS(3),
	1		SPDSET(3),
	1		SPDPRN(3),
	1		OUTBAS(3),
	1		OUTPUT(3),
	1		LVSPI(3),
	1		LVSPD(3),
	1		LVSPP(3),
	1		SPOUTI(3),
	1		SPOUTD(3),
	1		SPOUTP(3),
	1		LVLHI(3),
	1		LVLLO(3),
	1		SPDHI(3),
	1		SPDLO(3),
	1		CNTLSP(3),
	1		CRTLSP(3),
	1		LVLPRO(3),
	1		SPDPRO(3),
	1		SKIP,
	1		SPDAO(3),
	1		AMPPRN(3),
	1		AMPPRO(3),
	1		BEDLVL(3),
	1		SPEED(3),
	1		SETPT(3),
	1		SPDOUT(3),
	1		AMPS(3),
	1		FAIL(3),
	1		AMPI(3),
	1		AMPP(3),
	1		AMPD(3),
	1		AMPSET(3),
	1		AMPHI(3),
	1		AMPLO(3),
	1		AMPBAS(3),AMPEDB(3),LVLEDB(3)
C
	INTEGER*4	I,J,K,L,M,N,ADDRESS(2),BIT,XXX(3)/2,3,4/
C
	INTEGER*4	SPT(3)/885,581,622/,
	1		CLRCX(3),
	1		CTRLCX(3)
C
	INTEGER*4	UFO_OPEN
C
	CHARACTER*8	AOP(3)/'AD600045','AD600003','AD600034'/
C
	CHARACTER*8	DOP(4)/'DD600002','DD600003','DD600004','DD600010'/
C
	CHARACTER*8	AIP(15)/'AI613029','AI604030','AI602020','AI613042',
	1			'AI604032','AI602028','SP613469','SP604621',
	1			'SP602775','AO613014','AO604012','AO602001',
	1			'AI613043','AI604033','AI602023'/
C
	CHARACTER*8	DIP(6)/'DD614038','DD604028','DD602029',
	1		       'DI609389','DI604346','DI606362'/
C
	COMMON/GOODPTTBL/GPT
C
	EQUIVALENCE	(VALU(1),BEDLVL(1))
	EQUIVALENCE	(VALU(2),BEDLVL(2))
	EQUIVALENCE	(VALU(3),BEDLVL(3))
	EQUIVALENCE	(VALU(4),SPEED(1))
	EQUIVALENCE	(VALU(5),SPEED(2))
	EQUIVALENCE	(VALU(6),SPEED(3))
	EQUIVALENCE	(VALU(7),SETPT(1))
	EQUIVALENCE	(VALU(8),SETPT(2))
	EQUIVALENCE	(VALU(9),SETPT(3))
	EQUIVALENCE	(VALU(10),SPDOUT(1))
	EQUIVALENCE	(VALU(11),SPDOUT(2))
	EQUIVALENCE	(VALU(12),SPDOUT(3))
	EQUIVALENCE	(VALU(13),AMPS(1))
	EQUIVALENCE	(VALU(14),AMPS(2))
	EQUIVALENCE	(VALU(15),AMPS(3))
C
	EQUIVALENCE	(DI(1),CTRLCX(1))
	EQUIVALENCE	(DI(2),CTRLCX(2))
	EQUIVALENCE	(DI(3),CTRLCX(3))
	EQUIVALENCE	(DI(4),CLRCX(1))
	EQUIVALENCE	(DI(5),CLRCX(2))
	EQUIVALENCE	(DI(6),CLRCX(3))
C
	EXTERNAL	UFO_OPEN
C
5	CONTINUE
C
C	OPEN CONNECTION TO AGGL 1-2 POINT DIRECTORY
C
        status = LIB$SYS_TRNLOG('WESAPI_PDIR_0',
     1			spd_filename_len,spd_filename,,,)
C
	spd_filename(spd_filename_len+1:) = CHAR(0)
C
        access_type = RUNTIME
C
        spd_fd = SPD_open_file(%ref(spd_filename), access_type)
C
	DO 15	J=1,3	!GET THE 3 AGGL 1-2 ANALOG OUTPUT SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(AOP(J)//char(0)),AO(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
15	CONTINUE
C
	DO 25 J=1,4  !GET COMPUTER ACKNOWLEDGE DO SID AND SAAB ALARM DOS SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(DOP(J)//char(0)),DO(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
25	CONTINUE
C
	DO 30	J=1,15	!GET THE 15 AGGL 1-2 PROCESS VARIABLES SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(AIP(J)//char(0)),AI(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
30	CONTINUE
C
	DO 31	J=1,6	!GET THE 6 AGGL 1-2 DIGITAL INPUT SIDS
C
	        status = SPD_get_sid(spd_fd,%ref(DIP(J)//char(0)),DI(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
31	CONTINUE
C
C  Close the point directory connection
C
	status = SPD_close_file(spd_fd)
C
C  Open the connection to SHC memory for WESAPI access
	status = SHC_open_memory()
C
	IF (status .NE. SHC_OK) THEN
		IF (status .EQ. SHC_E_MEMOPEN)GOTO 88
C
		OPEN	(UNIT=22,FILE='CTL:COOLER.ERR',STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
		WRITE	(22,77)status
77		FORMAT	(' SHC open memory failure - error =',I4)
C
		CLOSE	(UNIT=22)
C
	   GO TO 99999
C
	ENDIF
C
88	CONTINUE
C
	DO 20 	I=1,3
		TIMERX(I)=0 	!RESET 30 SEC RUN TIMER
		FTIMER(I)=0     !RESET SAAB FAIL TIMER
		GOOD(I)=0       !RESET SAAB NOT FROZEN TIMER
		BAD(I)=0        !RESET SAAB IS FROZEN TIMER
20	CONTINUE
C
	CALL	SYS$BINTIM(TIME,ADDRESS)
	CALL	SYS$SCHDWK(,,ADDRESS,ADDRESS)
C
100	CONTINUE
C
	DO 150	I=1,15	!READ IN THE 15 PROCESS VALUES NEEDED FOR THIS PASS
C
		status = SHC_get_analog_val_stat( AI(I), valu(I), AS(I))
C
150	CONTINUE
C
	OPEN	(UNIT=1,FILE='CTL:COOLER.DAT',STATUS='OLD',
	1	RECL=102,ACCESS='DIRECT',RECORDTYPE='FIXED',
	1	FORM='UNFORMATTED',SHARED,USEROPEN=UFO_OPEN)
C
	READ	(1,REC=1)CONTRL,PRGLSP,LVLPRN,LVOBAS,
	1		 SPDSET,SPDPRN,OUTBAS,
	1		 OUTPUT,LVSPI,
	1		 LVSPD,LVSPP,SPOUTI,SPOUTD,
	1		 SPOUTP,LVLHI,LVLLO,SPDHI,
	1		 SPDLO,CNTLSP,CRTLSP,LVLPRO,
	1		 SPDPRO,FAIL,AMPI,AMPP,AMPD,
	1		 AMPSET,AMPHI,AMPLO,
	1		 AMPBAS,AMPPRN,AMPPRO,AMPEDB,LVLEDB
C
	DO 1000 I=1,3
C
		LVLPRN(I)=BEDLVL(I)
		SPDPRN(I)=SPEED(I)
		CNTLSP(I)=SETPT(I)
		SPDAO(I)=SPDOUT(I)
		AMPPRN(I)=AMPS(I)
		LAST(I)=LVLPRO(I)
C
		CALL CHKGPT(SPT(I),BIT)		!CHECK GPT ON CONTROLLER SPT
C
		IF (BIT .NE. 1) THEN
			PRGLSP(I)=CRTLSP(I)	!USE OPERATOR SETPOINT
		ELSE
			PRGLSP(I)=CNTLSP(I)	!USE CONTROLLER SETPOINT
		END IF
C
		status = SHC_get_digital_val_stat(CTRLCX(I),gp_sid,gp_bitnum,
	1	digital_val, digital_stat)	!SEE IF COOLER ON COMP
C
		IF (digital_val .EQ. 1) THEN
			CONTRL(I)=JIBCLR(CONTRL(I),0)	!ON COMP
		ELSE 
			CONTRL(I)=JIBSET(CONTRL(I),0)	!OFF COMP
			OUTPUT(I)=SPDAO(I)		!MATCH CONTROLLER OUTPUT
			OUTBAS(I)=SPDAO(I)		!RESET OUTPUT BASE
			LVOBAS(I)=SPDPRN(I)		!RESET BED LEVEL BASE
			AMPBAS(I)=SPDPRN(I)		!RESET AMPS BASE
			GOTO 900
		END IF
C
		status = SHC_get_digital_val_stat(CLRCX(I),gp_sid,gp_bitnum,
	1	digital_val, digital_stat)	!CHECK IF COOLER RUNNING
C
		IF (digital_val .EQ. 0)THEN		!COOLER IS OFF
			TIMERX(I)=15		!SET UP RUN TIMER
			GOTO 1000
		END IF
C
C	BED LEVEL PID OUTPUT IS NEW COOLER SPEED FLOATING SETPOINT
C
		IF (TIMERX(I) .EQ. 0)GOTO 500
C
		TIMERX(I)=TIMERX(I)-1
		OUTBAS(I)=OUTPUT(I)	!RESET OUTPUT BASE
		LVOBAS(I)=SPDPRN(I)	!RESET BED LEVEL BASE
		AMPBAS(I)=SPDPRN(I)	!RESET AMPS BASE
		GOTO 900
C
500		CONTINUE
C
		IF (BJTEST(CONTRL(I),2))GOTO 800 !IF SAAB IS FROZE SKIP CHECK
C
		IF ((LVLPRN(I) .GE. FAIL(I)).OR.
	1	    (LVLPRN(I) .LT. LFAIL(I)))THEN	!SAAB IS BAD
			IF (BJTEST(CONTRL(I),1))THEN	!ARE WE ALREADY ON AMPS
				FTIMER(I)=0		!YES RESET TIMER
				GOTO 800		!GO CALCULATE
			ELSE
				FTIMER(I)=FTIMER(I)+1	!HAS SAAB BEEN BO
				IF (FTIMER(I) .GE. 4)THEN	!FOR 5 SECS
					CONTRL(I)=JIBSET(CONTRL(I),1)
					FTIMER(I)=0	!YES INDICATE AMPS
				END IF
				GOTO 800		!GO CALCULATE
			END IF
		ELSE					!SAAB LOOKS GOOD
			IF (BJTEST(CONTRL(I),1))THEN	!ARE WE ON AMPS?
				FTIMER(I)=FTIMER(I)+1	!YES HAS SAAB BEEN
				IF (FTIMER(I) .GE. 15)THEN	!OK FOR 30 SECS
					CONTRL(I)=JIBCLR(CONTRL(I),1)	!YES
					FTIMER(I)=0	!GO BACK TO BED LVL
				END IF
				GOTO 800		!GO CALCULATE
			ELSE
				FTIMER(I)=0		!RESET TIMER
				GOTO 800		!GO CALCULATE
			END IF
		END IF
C
800		CONTINUE
C
		IF (BJTEST(CONTRL(I),1))THEN	!USE BED LVL OR AMPS
			TEMP=AMPPRN(I)-AMPSET(I)
			IF (ABS(TEMP) .LT. AMPEDB(I))TEMP=0	!NO ERROR
			CHECK=(TEMP*AMPI(I))+AMPBAS(I)          
			CALL HILO(CHECK,AMPHI(I),AMPLO(I))
			AMPBAS(I)=CHECK
C
			TEMP=TEMP*AMPP(I)
			CHECK=((AMPPRN(I)-AMPPRO(I))*AMPD(I))+TEMP+AMPBAS(I)
			CALL HILO(CHECK,AMPHI(I),AMPLO(I))
			SPDSET(I)=CHECK			!NEW SPEED SETPOINT
			LVOBAS(I)=AMPBAS(I)
		ELSE
			TEMP=LVLPRN(I)-PRGLSP(I)
			IF (ABS(TEMP) .LT. LVLEDB(I))TEMP=0	!NO ERROR
			CHECK=(TEMP*LVSPI(I))+LVOBAS(I)         
			CALL HILO(CHECK,LVLHI(I),LVLLO(I))
			LVOBAS(I)=CHECK
C
			TEMP=TEMP*LVSPP(I)
			CHECK=((LVLPRO(I)-LVLPRN(I))*LVSPD(I))+TEMP+LVOBAS(I)
			CALL HILO(CHECK,LVLHI(I),LVLLO(I))
			SPDSET(I)=CHECK			!NEW SPEED SETPOINT
			AMPBAS(I)=LVOBAS(I)
		END IF
C
C	SPEED SETPOINT TO OUTPUT IS STANDARD PID
C
		TEMP=SPDSET(I)-SPDPRN(I)
		CHECK=(TEMP*SPOUTI(I))+OUTBAS(I)
		CALL HILO(CHECK,SPDHI(I),SPDLO(I))
		OUTBAS(I)=CHECK
		TEMP=TEMP*SPOUTP(I)
		CHECK=((SPDPRO(I)-SPDPRN(I))*SPOUTD(I))+TEMP+OUTBAS(I)
		CALL HILO(CHECK,SPDHI(I),SPDLO(I))
		OUTPUT(I)=CHECK
C
900		CONTINUE
C
		LVLPRO(I)=LVLPRN(I)	!SAVE COOLER BED LVL LAST SCAN
		SPDPRO(I)=SPDPRN(I)	!SAVE COOLER SPEED LAST SCAN
		AMPPRO(I)=AMPPRN(I)	!SAVE COOLER AMPS LAST SCAN
C
		status = SHC_get_digital_val_stat(CTRLCX(I),gp_sid,gp_bitnum,
	1	digital_val, digital_stat)	!SEE IF COOLER ON COMP
C
		IF (digital_val .EQ. 0)GOTO 1000 !GO HERE IF OFF CONTROL
C
950		CONTINUE
C
		IF (LAST(I) .NE. LVLPRN(I))THEN	!SAAB HAS CHANGED
			BAD(I)=0	!RESET FROZEN COUNTER	
			GOOD(I)=GOOD(I)+1	!COUNT GOOD SCANS
			IF (GOOD(I) .GE. 5)THEN!GOOD FOR 10 SECS
				put_digital_val=0	! RESET SAAB ALARM
				status = SHC_put_point_quality(DO(I), 
	1					point_quality)
				status = SHC_put_digital_val( DO(I), 
	1					put_digital_val)
C
				CONTRL(I)=JIBCLR(CONTRL(I),2)	
				FTIMER(I)=15
				GOOD(I)=0
			END IF
		ELSE
			GOOD(I)=0	!RESET GOOD COUNTER	
			BAD(I)=BAD(I)+1	!COUNT BAD SCANS
			IF (BAD(I) .GE. 22)THEN	!BAD FOR 44 SECS
				put_digital_val=1	!ALARM CONTROL ROOM
				status = SHC_put_point_quality(DO(I), 
	1					point_quality)
				status = SHC_put_digital_val( DO(I), 
	1					put_digital_val)
C
				CONTRL(I)=JIBSET(CONTRL(I),2)	!SAAB FROZEN
				CONTRL(I)=JIBSET(CONTRL(I),1)	!USE AMPS
				BAD(I)=0
			END IF
		END IF
C
1000	CONTINUE
C
C	MAKE ALL PROCESS OUTPUTS (1 DO AND 3 AO'S)
C
	DO 2100	I=1,15
C
		TIMEOUT=IIBITS(AS(I),15,1)	!EXTRACT TIMED OUT BIT
C
		IF (TIMEOUT .EQ. 1)THEN		!IF ANY POINT IS TIMED OUT
C
			CALL	LIB$DATE_TIME(DATETIME)
C
			OPEN	(UNIT=22,FILE='CTL:COOLER.ERR',
	1		STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
			WRITE	(22,78)DATETIME
78			FORMAT	(' TIMED OUT POINTS DETECTED   ',A)
C
			CLOSE	(UNIT=22)
C
	   		GO TO 3000
C
		END IF
C
2100	CONTINUE
C
	IF (put_digital_val .EQ. 1)THEN	!PERFORM COMP ACKNOW USING DO
		put_digital_val=0	!IF RELAY IS OPEN THEN CLOSE IT
	ELSE
		put_digital_val=1	!IF RELAY IS CLOSED THEN OPEN IT
	END IF
C
	status = SHC_put_point_quality(DO(4), point_quality)
	status = SHC_put_digital_val( DO(4), put_digital_val)
C
	put_analog_val=OUTPUT(1)		!LINE 3 COOLER SPEED
	status = SHC_put_point_quality(AO(1), point_quality)
	status = SHC_put_analog_val(AO(1), put_analog_val)
C
	put_analog_val=OUTPUT(2)		!LINE 4 COOLER SPEED
	status = SHC_put_point_quality(AO(2), point_quality)
	status = SHC_put_analog_val(AO(2), put_analog_val)
C
	put_analog_val=OUTPUT(3)		!LINE 5 COOLER SPEED
	status = SHC_put_point_quality(AO(3), point_quality)
	status = SHC_put_analog_val(AO(3), put_analog_val)
C
3000	CONTINUE
C
	CRTLSP(1)=2.38
	CRTLSP(2)=2.38
	CRTLSP(3)=2.38
C
	WRITE	(1,REC=1)CONTRL,PRGLSP,LVLPRN,LVOBAS,
	1		 SPDSET,SPDPRN,OUTBAS,
	1		 OUTPUT,LVSPI,
	1		 LVSPD,LVSPP,SPOUTI,SPOUTD,
	1		 SPOUTP,LVLHI,LVLLO,SPDHI,
	1		 SPDLO,CNTLSP,CRTLSP,LVLPRO,
	1		 SPDPRO,FAIL,AMPI,AMPP,AMPD,
	1		 AMPSET,AMPHI,AMPLO,
	1		 AMPBAS,AMPPRN,AMPPRO,AMPEDB,LVLEDB
C
	CLOSE	(UNIT=1)
C
	CALL	SYS$HIBER()
	GOTO 100
C
99999	CONTINUE
C
	CALL	EXIT
C
	END
C
	SUBROUTINE	CHKGPT(POINT,BIT)
C
C	SUBROUTINE WILL RETURN GOODPT STATUS OF SELECTED ANALOG
C
	INTEGER*4	BIT,POINT,I,J,GPT(50)
C
	COMMON/GOODPTTBL/GPT
C
	I=(POINT/32)+1		!WORD IN TABLE
	J=MOD(POINT,32)		!BIT IN WORD
	BIT=JIBITS(GPT(I),J,1)	!EXTRACT BIT
	RETURN
	END
C
	SUBROUTINE	HILO(VALUE,HI,LO)
C
C	SUBROUTINE WILL DO HI/LO LIMIT CHECKING FOR CALCULATED VALUES
C
	REAL*4		VALUE,HI,LO
C
	IF (VALUE .GT. HI)VALUE=HI
	IF (VALUE .LT. LO)VALUE=LO
	RETURN
	END
