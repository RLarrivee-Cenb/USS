C
	PROGRAM COMSCN		!(COM SCANNER)
C
	IMPLICIT NONE
C
	INCLUDE	'($PRCDEF)'
C
	INCLUDE '($SSDEF)'
	INCLUDE '($IODEF)'
C
	INCLUDE 'WESAPI:SPD.DCL'
	INCLUDE 'WESAPI:SHC_defines.DCL'
	INCLUDE 'WESAPI:SHC_err.DCL'
C
	CHARACTER	DATETIME*23,	!TEMP STORAGE FOR COMP TIME
	1		DIGITS*2,	!ASCII SECONDS IN TIME
	1		FILE*18/'ANA:ANAMOD_COM.DAT'/,	!ANALOG DATABASE FILE
	1		ACTIVE*14/'ANA:COMACT.DAT'/,	!ACTIVE ACCUM FILE
	1		SIX*14/'ANA:COMSIX.DAT'/,	!SIX MIN ACCUM FILE
	1		TIME*8/'0 0:0:10'/	!PROGRAM RUN FREQUENCY
C
	INTEGER*4	REMX,
	1		SCNCLS,
	1		LOGSCH,
	1		STARTFLAG,
	1		RECORD/20/,	!LENGTH OF ANAMOD RECORD
	1		TOTALP/1200/,	!TOTAL POINTS IN SYSTEM
	1		RECORDA/2/,	!LENGTH OF LOG FILE RECORD
	1		STAT,
	1		PT,		!POINT TYPE
	1		ET,		!EQUATION TYPE
	1		SC,		!SMOOTHING COEFF
	1		RCX,		!RELATED CX
	1		ACPOINT(6),	!ANA/CX PROCESS POINTS
	1		INTC(4),	!INTEGER CONSTANTS
	1		SCANX(50),	!SCAN TABLE
	1		GPT(50),	!GOODPT TABLE
	1		I,J,K,L,M,N,	!INDEX REGISTERS
	1		CXPASS,
	1		CXCNTR,
	1		BIT,
	1		ACOUNT,		!COUNTER FOR ALARMS
	1		CXSTS(100),	!CX STATUS TABLE
	1		ADDRESS(2),
	1		TAI		!TOTAL POINTS IN WDPF TABLE
	INTEGER*4	SYS$CANWAK,INF
C
	PARAMETER	(TAI=9)	!TOTAL POINTS IN WDPF TABLE
C
	LOGICAL*4	BSTAT
C
	REAL*4		SECONDS/10.0/,	!PROG RUN FREQUENCY
	1		MIN,
	1		SEC,
	1		TSEC,
	1		TIMEX,
	1		REM,
	1		INTVL/10.0/,
	1		ACCUM,		!POINT ACCUMULATION
	1		OBS,		!POINT OBSERVATIONS
	1		LL,		!LOW LIMIT
	1		HL,		!HIGH LIMIT
	1		REALC,		!ANAMOD REAL CONSTANT
	1		CNTR,
	1		SUM,
	1		TEMP
	REAL*4		VALU,INFR,ANVL(TAI)
C
	INTEGER*4	UFO_OPEN
	INTEGER*2	AS(TAI),	!WDPF ANALOG STATUS
	1		QUALTY
C
	INTEGER*4	SID(TAI)
	INTEGER*4	LST(9)/992,869,985,785,788,743,745,786,747/
C
	CHARACTER*6	NAMEX/'COMSCN'/
	CHARACTER	PN*8,EU*6,ED*30
	CHARACTER*18	FILE3/'ANA:ANAPHR_COM.DAT'/
C
	CHARACTER*40    spd_filename
	INTEGER*2	spd_filename_len
	INTEGER*2	spd_fd
	INTEGER*2	access_type
	BYTE		extended_flag
	BYTE		gp_bit_num
	BYTE		inactive_flag
	INTEGER*4	gp_sid,status
	INTEGER*4	LIB$SYS_TRNLOG
C
	EXTERNAL	UFO_OPEN
C
	EQUIVALENCE (INF,INFR)
C
	COMMON/GOODPTTBL/GPT		!ANALOG PULSE GOODPOINT STATUS
	COMMON/CONTACTS/CXSTS		!CONTACT STATUS TABLE
	COMMON/SCANTBL/SCANX		!POINTS ON SCAN TABLE
C
C	INF=JIBSET(INF,15)
	INF=Z'C99E007F'
C
C	ENTER HERE ONLY ON A RESTART OF THE PROGRAM
C
C
C  Use the wesapi highway number to form the name of the wesapi logical that
C  names the highway 0 point directory file and get file name from the logical
        status = LIB$SYS_TRNLOG('WESAPI_PDIR_0',
     1			spd_filename_len,spd_filename,,,)

C  Put a NULL character (0) at the end of the file name string.  This is
C  necessary because the spd library functions expect string arguments
C  to be NULL terminated strings.
C
	spd_filename(spd_filename_len+1:) = CHAR(0)

C  Call the spd open file function to get access to the point directory file
C
        access_type = RUNTIME
        spd_fd = SPD_open_file(%ref(spd_filename), access_type)
C
	OPEN	(UNIT=3,FILE=FILE3,FORM='FORMATTED',
	1	ACCESS='DIRECT',STATUS='OLD',RECL=44,SHARED,
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
	DO 44	I=1,TAI
C
		READ	(3,33,REC=LST(I),ERR=55)PN,ED,EU  !WDPF 8 CHAR NAMES
33		FORMAT	(A,A,A)
C
C
C  Call the get sid function.  The point name argument must have a NULL (0)
C  at the end.
C
	        status = SPD_get_sid(spd_fd, %ref(PN//char(0)), SID(I),
	1		gp_sid, gp_bit_num, extended_flag, inactive_flag)
C
C
44	CONTINUE
C
55	CONTINUE
C
	CLOSE	(UNIT=3)
C
C  	Close the point directory connection
C
	status = SPD_close_file(spd_fd)
C
C  	Open the connection to SHC memory for WESAPI access
C
	status = SHC_open_memory()
C
	IF (status .NE. SHC_OK) THEN
		IF (status .EQ. SHC_E_MEMOPEN)GOTO 88
C
		OPEN	(UNIT=22,FILE='ANA:COMSCN.ERR',STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
		WRITE	(22,77)status,DATETIME
77		FORMAT	(' SHC open memory failure - error =',I4,2X,A)
C
		CLOSE	(UNIT=22)
C
	   GO TO 99999
C
	ENDIF
C
88	CONTINUE
C
C	OPEN THE ACTIVE ACCUMULATION FILE
C
	OPEN	(UNIT=3,NAME=ACTIVE,FORM='UNFORMATTED',SHARED,
	1	STATUS='OLD',RECL=RECORDA,ACCESS='DIRECT',
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
C	OPEN THE ANAMOD DATA BASE FILE
C
	OPEN	(UNIT=1,NAME=FILE,FORM='UNFORMATTED',SHARED,
	1	STATUS='OLD',RECL=RECORD,ACCESS='DIRECT',
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
5	CONTINUE
	STARTFLAG=0			!SET FIRST PASS FLAG
6	CONTINUE
	CALL	LIB$DATE_TIME(DATETIME)	!GET CURRENT TIME
	DIGITS=DATETIME(19:20)
	DECODE	(2,7,DIGITS)SEC		!ISOLATE SECONDS
	DIGITS=DATETIME(22:23)
	DECODE	(2,7,DIGITS)TSEC	!ISOLATE .XX SECONDS
7	FORMAT	(F2.0)
	TIMEX=SEC+TSEC/100.0		!COMBINE TO FOR REAL NUMBER
	REM=MOD(TIMEX,INTVL)
C
	IF (STARTFLAG .EQ. 1) GOTO 20	!IF 10 MARK ESTABLISHED SKIP
	IF (REM .LE. 0.55) GOTO 10	!IF ON 10 SEC MARK CONTINUE
C
	REMX=NINT(TIMEX/INTVL)		!OTHERWISE DELAY TILL NEXT
	REM=REAL(REMX)			!10 SEC MARK
	REM=REM+1
	REM=REM*INTVL
	SECONDS=REM-TIMEX
	CALL	LIB$WAIT(SECONDS)
	GOTO 	5
C
10	CONTINUE
	CALL	SYS$BINTIM(TIME,ADDRESS)	!CONVERT ASCII TIME TO BINARY
	CALL	SYS$SCHDWK(,,ADDRESS,ADDRESS)	!PUT PROG ON 10 SEC SCHED
C
20 	CONTINUE
	LOGSCH=0
	DIGITS=DATETIME(16:17)
	DECODE	(2,7,DIGITS)MIN		!ISOLATE MINUTES
	DIGITS=DATETIME(19:20)
	DECODE	(2,7,DIGITS)SEC		!ISOLATE SECONDS
	IF((MIN .EQ. 0).AND.(SEC .LT.5)) LOGSCH=1	
	IF((MIN .EQ. 6).AND.(SEC .LT.5)) LOGSCH=1	
	IF((MIN .EQ. 12).AND.(SEC .LT.5)) LOGSCH=1
	IF((MIN .EQ. 18).AND.(SEC .LT.5)) LOGSCH=1
	IF((MIN .EQ. 24).AND.(SEC .LT.5)) LOGSCH=1	
	IF((MIN .EQ. 30).AND.(SEC .LT.5)) LOGSCH=1	
	IF((MIN .EQ. 36).AND.(SEC .LT.5)) LOGSCH=1	
	IF((MIN .EQ. 42).AND.(SEC .LT.5)) LOGSCH=1	
	IF((MIN .EQ. 48).AND.(SEC .LT.5)) LOGSCH=1	
	IF((MIN .EQ. 54).AND.(SEC .LT.5)) LOGSCH=1	!SET LOG COLLAPSE
C							!FLAG EVERY SIX MINUTES
60	CONTINUE
	DO 80	I=1,TAI
		status = SHC_get_analog_val_stat( SID(I), VALU, AS(I))
C
		CALL	CLEAN_F_ZERO(VALU)
		ANVL(I)=VALU
C
C	USE BIT 0 IN AS(I) TO INDICATE STATUS FROM THE GET CALL
C
		IF (status .NE. SHC_OK) THEN
			AS(I)=1	!INDICATE BAD STATUS ON THE GET CALL
		ELSE
			AS(I)=IBCLR(AS(I),0) !RESET BIT 0 AND SAVE OTHER BITS
		END IF
C
80	CONTINUE
C
	DO 500 I=1,TAI		!PROCESS EACH POINT
C
		READ	(1,REC=LST(I))PT,ET,SC,RCX,LL,HL,ACPOINT,INTC,
	1		REALC
C
C		IF (PT .EQ. 0) GOTO 250	!IF POINT UNDEFINED THEN SKIP
C
		IF (ABS(ANVL(I)) .GT. 1000000.0) GOTO 250!BAD DATA FROM WDPF
C
		READ	(3,REC=I)ACCUM,OBS
C
		IF (RCX .EQ. 0) GOTO 300	!NO REL CX GO HERE
		IF (ET .EQ. 1) GOTO 300	!SKIP REL CX CHECK FOR OPER TIME
		J=(RCX/32)+1	!EXTRACT CXSTS LONGWORD
		K=MOD(RCX,32)	!EXTRACT CORRECT BIT
		BIT=JIBITS(CXSTS(J),K,1)	!EXTRACT BIT CONDITION
		IF (BIT .EQ. 1) GOTO 300	!REL CX CLOSED
C
250		CONTINUE
		GOTO 500
C
300		CONTINUE
		GOTO 2000	
C
2000		CONTINUE
		QUALTY=IIBITS(AS(I),8,2)	!EXTRACT QUALITY BITS
		IF (QUALTY .NE. 0)THEN		!IF QUALITY IS BAD
			GOTO 500
		END IF
C
		QUALTY=IIBITS(AS(I),15,1)	!EXTRACT TIMED OUT BIT
		IF (QUALTY .NE. 0)THEN		!IF POINT IS TIMED OUT
			GOTO 500
		END IF
C
		QUALTY=IIBITS(AS(I),0,1)	!EXTRACT SHC_GET STATUS
		IF (QUALTY .NE. 0)THEN		!GET CALL HAD BAD STATUS
			GOTO 500
		END IF
C
2100		CONTINUE
C
		ACCUM=ACCUM+ANVL(I)	!ACCUMULATE ANVAL VALUE
		OBS=OBS+1		!BUMP OBSERVATIONS
C
450		CONTINUE
		WRITE	(3,REC=I)ACCUM,OBS	!WRITE DATA TO ACTIVE FILE
C
500	CONTINUE
C
	IF (LOGSCH .EQ. 1) THEN	!SIX MINUTES HAS EXPIRED
C
C	OPEN THE SIX MINUTE ACCUMULATION FILE FOR ROLLING
C
		OPEN	(UNIT=2,NAME=SIX,FORM='UNFORMATTED',SHARED,
	1		ACCESS='DIRECT',STATUS='OLD',RECL=RECORDA,
	1		CARRIAGECONTROL='FORTRAN',RECORDTYPE='FIXED')
C
		DO 510 I=1,TAI
			M=(LST(I)/32)+1	!SCAN TABLE LONGWORD
			N=MOD(LST(I),32)	!BIT IN LONGWORD
			IF (.NOT. (BJTEST(SCANX(M),N))) GOTO 510!NOT ON SCAN
			READ	(3,REC=I)ACCUM,OBS	!READ ACTIVE
507			CONTINUE
			WRITE	(2,REC=I,ERR=508)ACCUM,OBS !WRITE TO HOUR
			GOTO 509	!NO ERROR CONTINUE
508			CONTINUE
			CALL LIB$WAIT(0.5)  !WAIT FOR RECORD TO FREEUP
			GOTO 507            !GO TRY AGAIN
509			CONTINUE
			ACCUM=0
			OBS=0
			WRITE	(3,REC=I)ACCUM,OBS	!CLEAR ACTIVE
510		CONTINUE
		CLOSE	(UNIT=2)
C
	END IF
C
C	DELAY TILL SCHEDULED WAKEUP
C
	CALL 	SYS$HIBER()	!HIBERNATE UNTIL WAKEUP
C
	IF (LOGSCH .EQ. 1)THEN			!IF END OF HOUR
		STARTFLAG=0	!REESTABLISH TIME MARK
		STAT=SYS$CANWAK(,NAMEX)
		IF (.NOT. STAT) THEN	!CANCEL ERROR
			OPEN	(UNIT=2,FILE='ANA:COMSCN.ERR',STATUS='UNKNOWN')
			WRITE	(UNIT=2,FMT=523)DATETIME
523			FORMAT	(' SYS$CANWAK ERROR   ',A)
			CLOSE	(UNIT=2)
		END IF
		GOTO 6
	END IF
C
	STARTFLAG=1		!SET FIRST PASS FLAG
C
	GOTO 6			!GO MAKE NEXT RUN
C
99999	CONTINUE
C
	CALL	EXIT
C
	END
C
C
C
	SUBROUTINE	CHKGPT(POINT,BSTAT)
C
C	SUBROUTINE WILL CHECK THE GOODPT STATUS ON A PARTICULAR
C	POINT AND RETURN THE STATUS TO THE MAIN PROGRAM
C
	IMPLICIT NONE
C
	INTEGER*4	POINT,
	1		I,
	1		J,
	1		GPT(50)	!COMMON GOODPT TABLE
C
	LOGICAL*4	BSTAT
C
	COMMON/GOODPTTBL/GPT
C
	I=(POINT/32)+1		!GOODPT TABLE LONGWORD
	J=MOD(POINT,32)		!BIT IN LONGWORD
	BSTAT=BJTEST(GPT(I),J)	!CHECK STATUS
	RETURN
	END
C
	SUBROUTINE	CLEAN_F_ZERO(VALU)
C
	INTEGER*4	VALU
C
	IF (VALU .EQ. z'00008000')VALU=0
	IF (VALU .EQ. z'C99E007F')VALU=0
C
	RETURN
C
	END
