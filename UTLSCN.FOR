C
	PROGRAM UTLSCN		!(UTILITIES ANALOG SCANNER)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	PROGRAM RUNS EVERY 10 SECONDS AND PERFORMS THE 
C	FOLLOWING FUNCTIONS:
C
C	1. PERFORM CALCULATIONS INVOLVING OTHER ANVAL POINTS
C	2. ALARM SELECTED POINTS
C	3. ACCUM ALAOG DATA INTO THE ACTIVE FILE
C	4. ACCUM PULSE DATA INTO THE ACTIVE FILE
C	5. DUMP THE ACTIVE FILE INTO THE HOUR FILE AT
C		HALF PAST THE HOUR
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	IMPLICIT NONE
C
	INCLUDE	'($PRCDEF)'
C
	INCLUDE '($SSDEF)'
	INCLUDE '($IODEF)'
C
	INCLUDE 'WESAPI:SPD.DCL'
	INCLUDE 'WESAPI:SHC_defines.DCL'
	INCLUDE 'WESAPI:SHC_err.DCL'
C
	CHARACTER	DATETIME*23,	!TEMP STORAGE FOR COMP TIME
	1		DIGITS*2,	!ASCII SECONDS IN TIME
	1		FILE*17/'ANA:UTLANAMOD.DAT'/,	!ANALOG DATABASE FILE
	1		ACTIVE*19/'LOGS:UTL_ACTIVE.DAT'/,	!ACTIVE FILE
	1		HOUR*17/'LOGS:UTL_HOUR.DAT'/,	!HOUR ACCUM FILE
	1		TIME*8/'0 0:0:10'/,	!PROGRAM RUN FREQUENCY
	1		PRCNAM*15/'LOGS:UTL_LOGSCH'/	!LOG COLLAPSE PROGRAM
C
	INTEGER*4	REMX,
	1		SCNCLS,
	1		LOGSCH,
	1		STARTFLAG,
	1		RECORD/20/,	!LENGTH OF ANAMOD RECORD
	1		TOTALP/500/,	!TOTAL POINTS IN SYSTEM
	1		RECORDA/2/,	!LENGTH OF LOG FILE RECORD
	1		STAT,
	1		PT,		!POINT TYPE
	1		ET,		!EQUATION TYPE
	1		SC,		!SMOOTHING COEFF
	1		RCX,		!RELATED CX
	1		ACPOINT(6),	!ANA/CX PROCESS POINTS
	1		INTC(4),	!INTEGER CONSTANTS
	1		SCANX(20),	!SCAN TABLE
	1		GPT(20),	!GOODPT TABLE
	1		CXSTS(100),
	1		I,J,K,L,M,N,	!INDEX REGISTERS
	1		CXPASS,
	1		CXCNTR,
	1		BIT,
	1		ACOUNT,		!COUNTER FOR ALARMS
	1		ADDRESS(2),
	1		TAI,		!TOTAL POINTS IN WDPF TABLE
	1		SYS$CREPRC	!CREATE PROCESS SYS SERVICE
	INTEGER*4	SYS$CANWAK
C
	PARAMETER	(TAI=251)	!TOTAL POINTS IN WDPF TABLE
C
	LOGICAL*4	BSTAT
C
	REAL*4		SECONDS/10.0/,	!PROG RUN FREQUENCY
	1		MIN,
	1		SEC,
	1		TSEC,
	1		TIMEX,
	1		REM,
	1		INTVL/10.0/,
	1		INTVLP/30.0/,
	1		ACCUM,		!POINT ACCUMULATION
	1		OBS,		!POINT OBSERVATIONS
	1		ANVAL(500),	!ANVAL TABLE STORAGE
	1		LL,		!LOW LIMIT
	1		HL,		!HIGH LIMIT
	1		REALC,		!ANAMOD REAL CONSTANT
	1		OPERT(3)/.002777,.16667,10.009/, !OPER TIME CONSTANTS
	1		CNTR,
	1		SUM,
	1		TEMP,
	1		AV(TAI)		!WDPF ANALOG VALUE
	REAL*4		VALU
C
	INTEGER*2	AS(TAI),	!WDPF ANALOG STATUS
	1		QUALTY
C
	INTEGER*4	SID(TAI)
C
	CHARACTER*6	NAMEX/'UTLSCN'/
	CHARACTER	PN*8,EU*6,ED*30
	CHARACTER*14	FILE3/'ANA:UTLPHR.DAT'/
C
	CHARACTER*40    spd_filename
	INTEGER*2	spd_filename_len
	INTEGER*2	spd_fd
	INTEGER*2	access_type
	BYTE		extended_flag
	BYTE		gp_bit_num
	BYTE		inactive_flag
	INTEGER*4	gp_sid,UFO_OPEN,status
	INTEGER*4	LIB$SYS_TRNLOG
C
	EXTERNAL	UFO_OPEN
C
	COMMON/UTL_ANVALTBL/ANVAL	!ANALOG PULSE VALUE TABLE
	COMMON/UTL_GOODPTTBL/GPT	!ANALOG PULSE GOODPOINT STATUS
	COMMON/UTL_SCANTBL/SCANX	!POINTS ON SCAN TABLE
C
C	ENTER HERE ONLY ON A RESTART OF THE PROGRAM
C
C
C  Use the wesapi highway number to form the name of the wesapi logical that
C  names the highway 0 point directory file and get file name from the logical
        status = LIB$SYS_TRNLOG('WESAPI_PDIR_2',
     1			spd_filename_len,spd_filename,,,)

C  Put a NULL character (0) at the end of the file name string.  This is
C  necessary because the spd library functions expect string arguments
C  to be NULL terminated strings.
C
	spd_filename(spd_filename_len+1:) = CHAR(0)

C  Call the spd open file function to get access to the point directory file
C
        access_type = RUNTIME
        spd_fd = SPD_open_file(%ref(spd_filename), access_type)
C
	OPEN	(UNIT=3,FILE=FILE3,FORM='FORMATTED',
	1	ACCESS='DIRECT',STATUS='OLD',RECL=44,SHARED,
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
	DO 44	I=1,TAI
C
		READ	(3,33,REC=I,ERR=55)PN,ED,EU 	!WDPF 8 CHAR NAMES
33		FORMAT	(A,A,A)
C
C
C  Call the get sid function.  The point name argument must have a NULL (0)
C  at the end.
C
	        status = SPD_get_sid(spd_fd, %ref(PN//char(0)), SID(I),
	1		gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
C
44	CONTINUE
C
55	CONTINUE
C
	CLOSE	(UNIT=3)
C
C  	Close the point directory connection
C
	status = SPD_close_file(spd_fd)
C
C  	Open the connection to SHC memory for WESAPI access
C
	status = SHC_open_memory()
C
	IF (status .NE. SHC_OK) THEN
		IF (status .EQ. SHC_E_MEMOPEN)GOTO 88
C
		OPEN	(UNIT=22,FILE='ANA:UTLSCN.ERR',STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
		WRITE	(22,77)status,DATETIME
77		FORMAT	(' SHC open memory failure - error =',I4,2X,A)
C
		CLOSE	(UNIT=22)
C
	   GO TO 99999
C
	ENDIF
C
88	CONTINUE
C
C	OPEN THE ACTIVE ACCUMULATION FILE
C
	OPEN	(UNIT=3,NAME=ACTIVE,FORM='UNFORMATTED',SHARED,
	1	STATUS='OLD',RECL=RECORDA,ACCESS='DIRECT',
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
C	OPEN THE ANAMOD DATA BASE FILE
C
	OPEN	(UNIT=1,NAME=FILE,FORM='UNFORMATTED',SHARED,
	1	STATUS='OLD',RECL=RECORD,ACCESS='DIRECT',
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
5	CONTINUE
	STARTFLAG=0			!SET FIRST PASS FLAG
6	CONTINUE
C
	CALL	LIB$DATE_TIME(DATETIME)	!GET CURRENT TIME
	DIGITS=DATETIME(19:20)
	DECODE	(2,7,DIGITS)SEC		!ISOLATE SECONDS
	DIGITS=DATETIME(22:23)
	DECODE	(2,7,DIGITS)TSEC	!ISOLATE .XX SECONDS
7	FORMAT	(F2.0)
	TIMEX=SEC+TSEC/100.0		!COMBINE TO FOR REAL NUMBER
	REM=MOD(TIMEX,INTVL)
C
	IF (STARTFLAG .EQ. 1) GOTO 20	!IF 10 MARK ESTABLISHED SKIP
	IF (REM .LE. 0.25) GOTO 10	!IF ON 10 SEC MARK CONTINUE
C
	REMX=NINT(TIMEX/INTVL)		!OTHERWISE DELAY TILL NEXT
	REM=REAL(REMX)			!10 SEC MARK
	REM=REM+1
	REM=REM*INTVL
	SECONDS=REM-TIMEX
	CALL	LIB$WAIT(SECONDS)
	GOTO 	5
C
10	CONTINUE
C
	CALL	SYS$BINTIM(TIME,ADDRESS)	!CONVERT ASCII TIME TO BINARY
	CALL	SYS$SCHDWK(,,ADDRESS,ADDRESS)	!PUT PROG ON 10 SEC SCHED
C
20 	CONTINUE
C
	REM=MOD(TIMEX,INTVLP)
C
	SCNCLS=0			!RESET 30 MARK FLAG FOR PULSES
	IF (REM .LE. 0 .999) SCNCLS=1	!IF 30 SEC MARK SET FLAG FOR PULSES
C
	LOGSCH=0
	DIGITS=DATETIME(16:17)
	DECODE	(2,7,DIGITS)MIN		!ISOLATE MINUTES
	IF((MIN .EQ. 30).AND.(SEC .LT.5)) LOGSCH=1	!IF HALF PAST THE
C					!HOUR SET LOG COLLAPSE FLAG
60	CONTINUE
	DO 80	I=1,TAI
		status = SHC_get_analog_val_stat( SID(I), VALU, AS(I))
		ANVAL(I)=VALU	!STORE THIS ANALOG IN ANVAL
C
C	USE BIT 0 IN AS(I) TO INDICATE STATUS FROM THE GET CALL
C
		IF (status .NE. SHC_OK) THEN
			AS(I)=1	!INDICATE BAD STATUS ON THE GET CALL
		ELSE
			AS(I)=IBCLR(AS(I),0) !RESET BIT 0 AND SAVE OTHER BITS
		END IF
C
80	CONTINUE
C
	ACOUNT=0	!CLEAR ANALOG ALRM COUNTER
C
	DO 500 I=1,TOTALP		!PROCESS EACH ANVAL POINT
C
		M=(I/32)+1	!SCAN TABLE LONGWORD
		N=MOD(I,32)	!BIT IN LONGWORD
		IF (.NOT. (BJTEST(SCANX(M),N))) GOTO 250!NOT ON SCAN
C
		READ	(1,REC=I)PT,ET,SC,RCX,LL,HL,ACPOINT,INTC,
	1		REALC
C
		IF (PT .EQ. 0) GOTO 250	!IF POINT UNDEFINED THEN SKIP
C
		IF (ABS(ANVAL(I)) .GT. 1000000.0) GOTO 250!BAD DATA FROM WDPF
C
		READ	(3,REC=I)ACCUM,OBS
C
		IF (RCX .EQ. 0) GOTO 300	!NO REL CX GO HERE
		IF (ET .EQ. 1) GOTO 300	!SKIP REL CX CHECK FOR OPER TIME
		J=(RCX/32)+1	!EXTRACT CXSTS LONGWORD
		K=MOD(RCX,32)	!EXTRACT CORRECT BIT
		BIT=JIBITS(CXSTS(J),K,1)	!EXTRACT BIT CONDITION
		IF (BIT .EQ. 1) GOTO 300	!REL CX CLOSED
C
		IF (ET .NE. 9) GOTO 250	!CHECK FOR MULTIPLE REL CX
		J=(ACPOINT(1)/32)+1	!EXTRACT CXSTS LONGWORD
		K=MOD(ACPOINT(1),32)	!EXTRACT CORRECT BIT
		BIT=JIBITS(CXSTS(J),K,1)	!EXTRACT BIT CONDITION
		IF (BIT .EQ. 1) GOTO 300	!OTHER REL CX CLOSED
C
250		CONTINUE
		GPT(M)=JIBCLR(GPT(M),N)	!RESET GOODPT BIT
		ANVAL(I)=0
		GOTO 500
C
300		CONTINUE
		GOTO	(1000,		!PULSE POINT
	1		2000,		!WDPF ANALOG INPUT
	1		3000)PT		!VAX CALCULATION
C
C		PROCESS PULSE POINTS
C
1000		CONTINUE
		IF (SCNCLS .EQ. 0) GOTO 500	!IF NOT 30 SEC MARK SKIP
C
C		PROCESS WDPF ANALOG INPUT 
C
2000		CONTINUE
		QUALTY=IIBITS(AS(I),8,2)	!EXTRACT QUALITY BITS
		IF (QUALTY .NE. 0)THEN		!IF QUALITY IS BAD
			GPT(M)=JIBCLR(GPT(M),N)	!RESET GOODPT BIT
			GOTO 500
		END IF
C
		QUALTY=IIBITS(AS(I),15,1)	!EXTRACT TIMED OUT BIT
		IF (QUALTY .NE. 0)THEN		!IF POINT IS TIMED OUT
			GPT(M)=JIBCLR(GPT(M),N)	!RESET GOODPT BIT
			GOTO 500
		END IF
C
		QUALTY=IIBITS(AS(I),0,1)	!EXTRACT SHC_GET STATUS
		IF (QUALTY .NE. 0)THEN		!GET CALL HAD BAD STATUS
			GPT(M)=JIBCLR(GPT(M),N)	!RESET GOODPT BIT
			GOTO 500
		END IF
C
2100		CONTINUE
		GPT(M)=JIBSET(GPT(M),N)	!SET GOODPT FOR THIS POINT
		ACCUM=ACCUM+ANVAL(I)	!ACCUMULATE ANVAL VALUE
		OBS=OBS+1		!BUMP OBSERVATIONS
C
		GOTO 450		!GO WRITE TO ACTIVE FILE
C
C		PROCESS VAX CALCULATIONS
C
3000		CONTINUE
		IF (SC .EQ. 0)GOTO 3050	!IF NOT 30SEC SCAN CONTINUE
		IF (SCNCLS .EQ. 0) GOTO 500	!IF NOT 30SEC MARK SKIP
3050		CONTINUE
		IF (ET .EQ. 0) GOTO 250	!NO EQUATION SKIP POINT
C
		GOTO (1100,1200,1300,1400,1400,1600,1200,1800)ET
C
C		*****OPERATING TIME CALCULATION*******
C
1100		CONTINUE
		CXPASS=0	!CX PASS TEST COUNTER
		CXCNTR=0	!CX COUNTER
		DO 1150 J=1,4
			IF (ACPOINT(J) .EQ. 0) GOTO 1150	
			CXCNTR=CXCNTR+1
			K=(ACPOINT(J)/32)+1
			L=MOD(ACPOINT(J),32)
			STAT=JIBITS(CXSTS(K),L,1)
			BIT=JIBITS(INTC(2),J-1,1)
			BIT=BIT+STAT
			IF (BIT .EQ. 1) THEN
				CXPASS=CXPASS+1
				GOTO 1150
			END IF
			BIT=JIBITS(INTC(1),J-1,1)
			IF (BIT .EQ. 1) GOTO 1150
1140			CONTINUE
			ANVAL(I)=0
			GOTO 250
1150		CONTINUE
		IF (CXCNTR .EQ. 0) GOTO 1140
		IF (CXPASS .EQ. 0) GOTO 1140
		IF ((INTC(3) .LT. 1).OR.(INTC(3) .GT. 3)) GOTO 1140
		ANVAL(I)=OPERT(INTC(3))	!ADD OPER TIME
		GOTO 2100
C
C		*****SUMMATION CALCULATION************
C
1200		CONTINUE
		CNTR=0			!COUNTS GOOD POINTS
		SUM=0			!INITIALIZE ACCUM
		DO 1250 J=1,6
			IF (ACPOINT(J) .EQ.0) GOTO 1250
			CXCNTR=ABS(ACPOINT(J))	!MAKE POINT POSITIVE
			CALL	CHKGPT(CXCNTR,BSTAT)	!CHECK GPT
			IF (.NOT. BSTAT) GOTO 1250	!SKIP IF GP RESET
			CNTR=CNTR+1
			IF (ACPOINT(J) .LT.0) THEN
				K=-ACPOINT(J)
				SUM=SUM-ANVAL(K)	!SUBTRACT VALUE
			ELSE
				SUM=SUM+ANVAL(ACPOINT(J))	!ADD VALUE
			END IF
1250		CONTINUE
		IF (CNTR .EQ.0) GOTO 250	!NO GOOD VALUES TO SUM
		IF (ET .EQ. 7) THEN
			ANVAL(I)=SUM/CNTR	!IF AVG OF SUM DO DIVISION
		ELSE
			ANVAL(I)=SUM		!ELSE JUST DO SUMMATION
		END IF
		GOTO 2100
C
C		****POINT TIMES CONSTANT**************
C
1300		CONTINUE
		IF (ACPOINT(1) .EQ. 0) GOTO 250
		CALL	CHKGPT(ACPOINT(1),BSTAT)	!CHECK GPT
		IF (.NOT. BSTAT) GOTO 250		!GP RESET
		ANVAL(I)=ANVAL(ACPOINT(1))*REALC	!POINT * CONST
		GOTO 2100
C
C		****POINT TIMES POINT OR POINT / POINT******
C
1400		CONTINUE
		IF ((ACPOINT(1) .EQ. 0).OR.(ACPOINT(2) .EQ. 0)) GOTO 250
		CALL	CHKGPT(ACPOINT(1),BSTAT)	!CHECK GPT
		IF (.NOT. BSTAT) GOTO 250		!CHECK GP 
		CALL	CHKGPT(ACPOINT(2),BSTAT)	!CHECK GPT
		IF (.NOT. BSTAT) GOTO 250		!CHECK GP
		IF (ET .EQ. 4) THEN	!DETERMINE IF MULT OR DIV
			IF (ANVAL(ACPOINT(2)) .EQ. 0) GOTO 250
			TEMP=ANVAL(ACPOINT(1))/ANVAL(ACPOINT(2))
		ELSE
			TEMP=ANVAL(ACPOINT(1))*ANVAL(ACPOINT(2))
		END IF
		IF (INTC(1) .EQ. 0) TEMP=TEMP+REALC
		IF (INTC(1) .EQ. 1) TEMP=TEMP-REALC
		IF (INTC(1) .EQ. 2) TEMP=TEMP*REALC
		IF (INTC(1) .EQ. 3) TEMP=TEMP/REALC
		ANVAL(I)=TEMP		!STORE FINAL RESULTS IN ANVAL
		GOTO 2100
C
C		****CONSECUTIVE SUM*******************
C
1600		CONTINUE
		SUM=0			!INITIALIZE SUM
		CNTR=0			!COUNTS POINTS SUMMED
		DO 1650 J=1,4
			IF (ACPOINT(J) .EQ. 0) GOTO 1650
			CXCNTR=ACPOINT(J)	!STARTING POINT FOR THIS SERIES
			DO 1640 K=1,INTC(J)
				CALL CHKGPT(CXCNTR,BSTAT)	!CHECK GPT
				IF (.NOT. BSTAT) GOTO 1630	
				SUM=SUM+ANVAL(CXCNTR)	!ACCUM THIS POINT
				CNTR=CNTR+1
1630				CONTINUE
				CXCNTR = CXCNTR+1
1640			CONTINUE
1650		CONTINUE
		IF (CNTR .EQ. 0) GOTO 250	!NO POINTS WERE ADDED
		ANVAL(I)=SUM			!NEW SUMATION
		GOTO 2100
C
C		****ACCUMULATE ONLY*******************
C
1800		CONTINUE
		IF (.NOT. BJTEST(GPT(M),N)) GOTO 250	!CHECK GP SKIP IF RESET
		GOTO 2100
C
450		CONTINUE
		WRITE	(3,REC=I)ACCUM,OBS	!WRITE DATA TO ACTIVE FILE
C
500	CONTINUE
C
	IF (LOGSCH .EQ. 1) THEN	!IS IT TIME FOR LOGS...HALF PAST HOUR
C
C	OPEN THE HOUR ACCUMULATION FILE FOR ROLLING
C
		OPEN	(UNIT=2,NAME=HOUR,FORM='UNFORMATTED',SHARED,
	1		ACCESS='DIRECT',STATUS='OLD',RECL=RECORDA,
	1		CARRIAGECONTROL='FORTRAN',RECORDTYPE='FIXED')
C
		DO 510 I=1,TOTALP
			READ	(3,REC=I)ACCUM,OBS	!READ ACTIVE
			WRITE	(2,REC=I)ACCUM,OBS	!WRITE TO HOUR
			ACCUM=0
			OBS=0
			WRITE	(3,REC=I)ACCUM,OBS	!CLEAR ACTIVE
510		CONTINUE
		CLOSE	(UNIT=2)
C
		STAT=SYS$CREPRC(,PRCNAM,,,,,,PRCNAM,%VAL(4),,,
	1	%VAL(PRC$M_DETACH.OR.PRC$M_NOACNT))
C		
C		TURN ON LOG COLLAPSE PROGRAM TO ROLL FILES
C
		IF (.NOT. STAT) THEN	!TURN ON ERROR
			OPEN	(UNIT=2,FILE='ANA:UTLSCN.ERR',STATUS='UNKNOWN')
			WRITE	(UNIT=2,FMT=520)DATETIME
520			FORMAT	(' LOGSCH PROG TURNON ERROR   ',A)
			CLOSE	(UNIT=2)
		END IF
	END IF
C
C	DELAY TILL SCHEDULED WAKEUP
C
	CLOSE	(UNIT=3)	!CLOSE ACTIVE FILE
	CALL 	SYS$HIBER()	!HIBERNATE UNTIL WAKEUP
C
	OPEN	(UNIT=3,NAME=ACTIVE,FORM='UNFORMATTED',SHARED,
	1	STATUS='OLD',RECL=RECORDA,ACCESS='DIRECT',
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
	IF (LOGSCH .EQ. 1)THEN
		STARTFLAG=0	!REESTABLISH TIME MARK
		STAT=SYS$CANWAK(,NAMEX)
		IF (.NOT. STAT) THEN	!CANCEL ERROR
			OPEN	(UNIT=2,FILE='ANA:UTLSCN.ERR',STATUS='UNKNOWN')
			WRITE	(UNIT=2,FMT=521)DATETIME
521			FORMAT	(' SYS$CANWAK ERROR   ',A)
			CLOSE	(UNIT=2)
		END IF
		GOTO 6
	END IF
C
	STARTFLAG=1		!SET FIRST PASS FLAG
C
	GOTO 6			!GO MAKE NEXT RUN
C
99999	CONTINUE
C
	CALL	EXIT
C
	END
C
C
C
	SUBROUTINE	CHKGPT(POINT,BSTAT)
C
C	SUBROUTINE WILL CHECK THE GOODPT STATUS ON A PARTICULAR
C	POINT AND RETURN THE STATUS TO THE MAIN PROGRAM
C
	IMPLICIT NONE
C
	INTEGER*4	POINT,
	1		I,
	1		J,
	1		GPT(20)	!COMMON GOODPT TABLE
C
	LOGICAL*4	BSTAT
C
	COMMON/UTL_GOODPTTBL/GPT
C
	I=(POINT/32)+1		!GOODPT TABLE LONGWORD
	J=MOD(POINT,32)		!BIT IN LONGWORD
	BSTAT=BJTEST(GPT(I),J)	!CHECK STATUS
	RETURN
	END
		
