C
	PROGRAM KLNBRG 
C
C	(KILN BEARINGS)
C
C	THIS PROGRAM WILL ALERT THE CONTROL ROOM  
C	TO ANY RAPID RISE IN TEMPERATURE FOR ANY ONE 
C	OF THE 108 BEARINGS LISTED BELOW.  IF A BEARING 
C	TEMPERATURE SHOULD RISE AT LEAST 5 DEGREES IN
C	30 MINUTES OR LESS AN ALARM MSG IS PRINTED.
C
C	FAN BEARING TEMPERATURES ARE CHECKED ONLY ABOVE 100
C	DEGREES.
C
C	REVISION HISTORY
C
C	THIS PROGRAM HAS BEEN REVISED ON 12-02-2004 TO PROVIDE
C	A SPECIFIC NOTIFICATION OF ALARM SENT TO THE STEP12
C	AGGLOMERATOR DCS WHEN AN INDIVIDUAL BEARING GOES INTO ALARM.
C	THIS IS DONE BY MEANS OF PACKED GROUP POINTS (GP RECORD TYPES)
C	AND SETTING THE CORRESPONDING BIT FOR EACH OF THE 108 BEARINGS.
C	A TOTAL OF 5 GP POINTS ARE USED (0-15) TO INDIVIDUALLY ALARM 
C	ALL 108 BEARINGS.  LOGIC IN THE DCS CONVERTS EACH ALARM BIT
C	TO A DL RECORD TYPE POINT TO ALARM THE OPERATOR. 
C
C	SERVICE CENTER TICKET PM
C	PLANVIEW ID
C	REVISION XX-XX-XXXX THE FOLLOWING MODIFICATIONS HAVE BEEN
C	MADE PER BILL SIMONSON:  A BASELINE OF 70 DEGREES FAHRENHEIT FOR ALL
C	MILL AND KILN BEARINGS. A RELATED CONTACT CHECK HAS BEEN ADDED FOR 
C	ALL BEARINGS.  IF THE RELATED CONTACT IS OPEN THE 30 MINUTE TABLE FOR
C	THE ASSOCIATED BEARING IS ZEROED OUT.  ONLY TEMPERATURES ABOVE THE 
C	BASELINE WHEN THE RELATED CONTACT IS CLOSED WILL BE USED TO CALCULATE
C	RAPID RISE ALARMS
C
C	FORT/NOOP/NOALIGN/WARN=NOALIGN/FLOAT=D_FLOAT KLNBRG
C
C	LINK KLNBRG,KLNBRG/OPT,WESAPI_LIB:WESAPI/OPT
C
	IMPLICIT NONE
C
	INCLUDE 'WESAPI:SPD.DCL'
	INCLUDE 'WESAPI:SHC_defines.DCL'
	INCLUDE 'WESAPI:SHC_err.DCL'
C
	INTEGER*4	LIB$SYS_TRNLOG
	INTEGER*4 	status
	CHARACTER*20	highway
	CHARACTER*40    spd_filename
	CHARACTER*80	c_ascii_val
	INTEGER*2	spd_filename_len
	CHARACTER*2     field_name/'TB'/
	INTEGER*2	spd_fd
	INTEGER*2       c_short_val
	INTEGER*2	length
	INTEGER*2	access_type
	CHARACTER*8	pt_name
	BYTE		extended_flag
	BYTE		gp_bit_num
	BYTE		inactive_flag
	INTEGER*4	gp_sid,SID(3)
	INTEGER*2       gp_op_mask
	INTEGER*2       gp_val_mask(7)
C
	INTEGER*2	PUT_DIGITAL_VAL
C
	CHARACTER*8	PNT(3)/'DD600016','DD600014','DD600013'/
	CHARACTER*8	GPNT(7)/'GP600001','GP600002','GP600003',
	1			'GP600004','GP600005','GP600006',
	1			'GP600007'/
C
	REAL*4		TEMPS(30),VALUE,DIFF,ANVAL(1200)
	INTEGER*4	I,J,K,M,N,P,ADDRESS(2)
	INTEGER*4	NORM(4)/'33'O,'133'O,'62'O,'167'O/
	INTEGER*4	LARG(4)/'33'O,'133'O,'70'O,'167'O/
	INTEGER*4	LN4,LN5,UFO_OPEN,BITM,BITE
	INTEGER*4	POINT_QUALITY,GSID(7),CXSTS(100),BIT,POINT
C
	INTEGER*4	BRGS(108)/290,306,291,307,292,308,
	1			  293,309,294,310,295,311,
	1			  296,312,297,313,298,314,
	1			  299,315,300,316,301,317,
	1			  302,318,303,319,304,320,
	1			  305,321,49,165,51,167,
	1			  790,792,789,791,799,800,796,797,
	1			  807,808,804,805,742,741,753,752,
	1			  131,132,129,130,108,109,106,107,
	1			  119,120,117,118,141,142,283,405,
	1			  406,407,248,249,962,247,224,225,
	1			  222,223,236,237,234,235,257,258,
	1			  993,994,259,260,995,996,829,828,
	1			  833,834,839,838,842,843,50,281,
	1			  827,826,830,831,837,836,840,841/
C
	INTEGER*4	RCXM(108)/368,575,368,575,368,575,368,575,
	1			  368,575,368,575,368,575,368,575,
	1			  368,575,368,575,368,575,368,575,
	1			  368,575,368,575,368,575,368,575,
	1			  251,267,251,267,1010,1010,1010,1010,
	1			  1212,1212,1212,1212,1213,1213,1213,1213,
	1			  1222,1222,1223,1223,1656,1656,1656,1656,
	1			  366,366,366,366,1017,1017,1017,1017,
	1			  375,375,375,375,376,376,571,571,
	1			  571,571,573,573,573,573,574,574,
	1			  574,574,582,582,582,582,583,583,
	1			  583,583,1214,1214,1214,1214,1214,1214,
	1			  1214,1214,1637,1637,1214,1214,1214,1214,
	1			  1214,1214,1214,1214/
C
	INTEGER*4	RCXE(108)/369,576,369,576,369,576,369,576,
	1			  369,576,369,576,369,576,369,576,
	1			  369,576,369,576,369,576,369,576,
	1			  369,576,369,576,369,576,369,576,
	1			  0,0,0,0,0,0,0,0,
	1			  0,0,0,0,0,0,0,0,
	1			  0,0,0,0,0,0,0,0,
	1			  0,0,0,0,0,0,0,0,
	1			  0,0,0,0,0,0,0,0,
	1			  0,0,0,0,0,0,0,0,
	1			  0,0,0,0,0,0,0,0,
	1			  0,0,1215,1215,1215,1215,1215,1215,
	1			  1215,1215,0,0,1215,1215,1215,1215,
	1			  1215,1215,1215,1215/
C
	CHARACTER*15	FILE/'GP:BRGTEMPS.DAT'/
	CHARACTER*30	ED		!ENGLISH DESCRIPTION OF ANALOG
	CHARACTER*6	EU		!ENGINEERING UNITS
	CHARACTER*8	PN		!WDPF POINT NUMBER
	CHARACTER*23	DATETIME
	CHARACTER*8	TIME/'0 0:1:00'/
	CHARACTER*1	BELL,NORMX(4),LARGX(4)
	CHARACTER*1	TYP(108)/'K','K','K','K','K','K',
	1			 'K','K','K','K','K','K',
	1			 'K','K','K','K','K','K',
	1			 'K','K','K','K','K','K',
	1			 'K','K','K','K','K','K',
	1			 'K','K','K','K','K','K',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'F','F','F','F','F','F',
	1			 'K','K','K','K','K','K',
	1			 'K','K','K','K','K','K',
	1			 'K','K','K','K','K','K'/
C
	EXTERNAL	UFO_OPEN
C
	COMMON/ANVALTBL/ANVAL
	COMMON/CONTACTS/CXSTS		!CONTACT STATUS TABLE
C
	BELL=CHAR(007)
	DO 10 I=1,4
		NORMX(I)=CHAR(NORM(I))	!CONTROL SEQ FOR NORM PRINT
		LARGX(I)=CHAR(LARG(I))	!CONTROL SEQ FOR LARGE PRINT
10	CONTINUE
C
	OPEN	(UNIT=2,NAME=FILE,FORM='UNFORMATTED',SHARED,
	1	ACCESS='DIRECT',STATUS='OLD',RECL=30,
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
	DO 150 I=1,108			!FOR EACH BEARING
C
		BITM=0
		BITE=0
		BIT=0
C
		POINT=RCXM(I)		!MAIN MOTOR RUN CX
		M=(POINT/32)+1		!WORD IN CX TABLE
		N=MOD(POINT,32)		!BIT IN WORD
		BITM=JIBITS(CXSTS(M),N,1)
C
		IF (RCXE(I) .NE. 0)THEN
			POINT=RCXE(I)		!EMERGENCY MOTOR RUN CX
			M=(POINT/32)+1		!WORD IN CX TABLE
			N=MOD(POINT,32)		!BIT IN WORD
			BITE=JIBITS(CXSTS(M),N,1)
		END IF
C
		BIT=BITM+BITE
C
		IF (BIT .EQ. 0)THEN	EQUIPMENT IS OFF ZERO OUT BRG TABLE
			DO 50 J=1,30
				TEMPS(J)=0
50			CONTINUE
		GOTO 125
		END IF
C
		IF (TYP(I) .EQ. 'K')THEN	!DO WE HAVE A KILN OR MILL BRG
			IF (ANVAL(BRGS(I)) .LE. 70)THEN !NOT AT BASELINE
				DO 60 J=1,30
					TEMPS(J)=0
60				CONTINUE
				GOTO 125
			END IF
		END IF
C
		IF (TYP(I) .EQ. 'F')THEN	!DO WE HAVE A FAN BRG
			IF (ANVAL(BRGS(I)) .LE. 100)THEN !NOT AT BASELINE
				DO 70 J=1,30
					TEMPS(J)=0
70				CONTINUE
				GOTO 125
			END IF
		END IF
C
		K=BRGS(I)		!LOAD BEARING TEMP	
		DO 100 J=1,30		!AND INITIALIZE 30 MIN TABLE
			TEMPS(J)=ANVAL(K)
100		CONTINUE
C
125		CONTINUE
C
		WRITE (2,REC=I)TEMPS	!SEND TABLE TO FILE
150	CONTINUE
C
 	CLOSE	(UNIT=2)	
C
C  Use the wesapi highway number to form the name of the wesapi logical that
C  names the highway 0 point directory file and get file name from the logical
        status = LIB$SYS_TRNLOG('WESAPI_PDIR_0',
     1			spd_filename_len,spd_filename,,,)

C  Put a NULL character (0) at the end of the file name string.  This is
C  necessary because the spd library functions expect string arguments
C  to be NULL terminated strings.
C
	spd_filename(spd_filename_len+1:) = CHAR(0)

C  Call the spd open file function to get access to the point directory file
C
        access_type = RUNTIME
        spd_fd = SPD_open_file(%ref(spd_filename), access_type)
C
	DO 102	J=1,3	!GET THE 3 CONTACT OUTPUT SIDS
C
C  Call the get sid function.  The point name argument must have a NULL (0)
C  at the end.
C
	        status = SPD_get_sid(spd_fd, %ref(PNT(J)//char(0)), SID(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
102	CONTINUE
C
	DO 103	J=1,7	!GET THE 7 PACKED GROUP SIDS
C
C  Call the get sid function.  The point name argument must have a NULL (0)
C  at the end.
C
	        status = SPD_get_sid(spd_fd, %ref(GPNT(J)//char(0)), GSID(J),
     x		             gp_sid, gp_bit_num, extended_flag, inactive_flag)

C
103	CONTINUE
C  Close the point directory connection
C
	status = SPD_close_file(spd_fd)
C
C  Open the connection to SHC memory for WESAPI access
	status = SHC_open_memory()
	IF (status .NE. SHC_OK) THEN
		IF (status .EQ. SHC_E_MEMOPEN)GOTO 88
C
		OPEN	(UNIT=22,FILE='GP:KLNBRG.ERR',STATUS='UNKNOWN',
	1		 ACCESS='APPEND')
C
		WRITE	(22,77)status
77		FORMAT	(' SHC open memory failure - error =',I4)
C
		CLOSE	(UNIT=22)
C
	   GO TO 99999
	ENDIF

88	CONTINUE
C
	status = SHC_put_point_quality( SID(1), point_quality)
	status = SHC_put_point_quality( SID(2), point_quality)
	status = SHC_put_point_quality( SID(3), point_quality)
C
	field_name='ED'
	length=30
	c_ascii_val='LINE 3 BEARING TEMP RAPID RISE'
C
	STATUS=	SHC_CHANGE_ASCII_ATTRIBUTE(SID(1),%REF(FIELD_NAME),
	1		LENGTH,%REF(C_ASCII_VAL))
C
	c_ascii_val='LINE 4 BEARING TEMP RAPID RISE'
C
	STATUS=	SHC_CHANGE_ASCII_ATTRIBUTE(SID(2),%REF(FIELD_NAME),
	1		LENGTH,%REF(C_ASCII_VAL))
C
	c_ascii_val='LINE 5 BEARING TEMP RAPID RISE'
C
	STATUS=	SHC_CHANGE_ASCII_ATTRIBUTE(SID(3),%REF(FIELD_NAME),
	1		LENGTH,%REF(C_ASCII_VAL))
C
	CALL	SYS$BINTIM(TIME,ADDRESS)
	CALL	SYS$SCHDWK(,,ADDRESS,ADDRESS)
C
250	CONTINUE
C
	gp_val_mask(1)=0
	gp_val_mask(2)=0
	gp_val_mask(3)=0
	gp_val_mask(4)=0
	gp_val_mask(5)=0
	gp_val_mask(6)=0
	gp_val_mask(7)=0
C
	gp_op_mask=65535	 !AFFECT ALL BITS
c
	PUT_DIGITAL_VAL=0
	status = SHC_put_digital_val( SID(1), put_digital_val) !CLEAR L3 ALARM
	status = SHC_put_digital_val( SID(2), put_digital_val) !CLEAR L4 ALARM
	status = SHC_put_digital_val( SID(3), put_digital_val) !CLEAR L5 ALARM
C
	OPEN	(UNIT=2,NAME=FILE,FORM='UNFORMATTED',SHARED,
	1	ACCESS='DIRECT',STATUS='OLD',RECL=30,
	1	RECORDTYPE='FIXED',USEROPEN=UFO_OPEN)
C
	DO 350 I=1,108			!UPDATE EACH BEARING'S TABLE
		READ (2,REC=I)TEMPS	!BRING IN BRG RECORD
		K=BRGS(I) 		!BRG'S ANVAL NUMBER
		VALUE=ANVAL(K)		!LOAD TEMP FOR THIS BEARING
C
		IF (TYP(I) .NE. 'F')GOTO 222	!IF NOT FAN BRG SKIP
C
		IF (VALUE .LT. 100)GOTO 320	!SKIP CHECK BELOW 100
C
C	HAS THERE BEEN A 5 DEGREE RISE IN TEMP IN LAST 30 MINUTES?
222		CONTINUE
C
		DO 300 J=1,30
			DIFF=VALUE-TEMPS(J)
			IF (DIFF .GE. 5.0)GOTO 500	!YES THERE HAS
C
300		CONTINUE
C
C		NO ALARM FOR THIS BEARING....SHUFFLE IN NEWEST
C		TEMP INTO TOP OF 30 MIN TABLE
C
320		CONTINUE
C
		DO 325 J=29,1,-1
			TEMPS(J+1)=TEMPS(J)
325		CONTINUE
		TEMPS(1)=VALUE		!NEW TEMP THIS MINUTE
C
345		WRITE (2,REC=I)TEMPS	!WRITE THIS BRG RECORD BACK
350	CONTINUE
C
	CLOSE	(UNIT=2)
C
	status = SHC_put_pkd_group_val(GSID(1),gp_op_mask, gp_val_mask(1))
	status = SHC_put_pkd_group_val(GSID(2),gp_op_mask, gp_val_mask(2))
	status = SHC_put_pkd_group_val(GSID(3),gp_op_mask, gp_val_mask(3))
	status = SHC_put_pkd_group_val(GSID(4),gp_op_mask, gp_val_mask(4))
	status = SHC_put_pkd_group_val(GSID(5),gp_op_mask, gp_val_mask(5))
	status = SHC_put_pkd_group_val(GSID(6),gp_op_mask, gp_val_mask(6))
	status = SHC_put_pkd_group_val(GSID(7),gp_op_mask, gp_val_mask(7))
C
C	DELAY FOR 1 MINUTE
C
400	CONTINUE
	CALL	SYS$HIBER()
	GOTO 250			!GO RUN AGAIN		
C
C	WE HAVE AN ALARM ... PRINT MSG AND LOAD TABLE
C
500	CONTINUE
	OPEN	(UNIT=3,FILE='ANA:ANAPHR.DAT',FORM='FORMATTED',
	1	ACCESS='DIRECT',STATUS='OLD',RECL=44,
	1	USEROPEN=UFO_OPEN,SHARED,
	1	CARRIAGECONTROL='LIST',RECORDTYPE='FIXED')
C
	OPEN	(UNIT=4,FILE='LTA015:',STATUS='UNKNOWN')
C
	CALL	LIB$DATE_TIME(DATETIME)	!GET CURRENT DATE AND TIME
C
	READ	(3,530,REC=K)PN,ED,EU	!GET ANAMOD DATA
530	FORMAT	(A,A,A)
	CLOSE	(UNIT=3)
C
	IF (ED(5:6) .EQ. '03')THEN	!LINE 3 ALARM
		PUT_DIGITAL_VAL=1
		status = SHC_put_point_quality( SID(1), point_quality)
		status = SHC_put_digital_val( SID(1), put_digital_val) 
	END IF
C
	IF (ED(5:6) .EQ. '04')THEN	!LINE 4 ALARM
		PUT_DIGITAL_VAL=1
		status = SHC_put_point_quality( SID(2), point_quality)
		status = SHC_put_digital_val( SID(2), put_digital_val) 
	END IF
C
	IF (ED(5:6) .EQ. '05')THEN	!LINE 5 ALARM
		PUT_DIGITAL_VAL=1
		status = SHC_put_point_quality( SID(3), point_quality)
		status = SHC_put_digital_val( SID(3), put_digital_val) 
	END IF
C
	WRITE	(4,549,ERR=575)LARGX		!SET PRINT TYPE TO LARGE
549	FORMAT	(' ',A,A,A,A)
C
	WRITE	(4,550,ERR=575)BELL,BELL,BELL,PN,TEMPS(J),VALUE,DATETIME,ED
550	FORMAT	(' ',A,A,A,'A',1X,A,' RAPID TEMPERATURE RISE ',2F6.1,
	1	1X,A,1X,A)
C
	WRITE	(4,549,ERR=575)NORMX		!SET PRINT TYPE TO NORMAL
C
575	CONTINUE
C
	CLOSE	(UNIT=4)
C
	DO 600 M=1,30
		TEMPS(M)=VALUE		!INIT TABLE WITH NEW VALUE
600	CONTINUE
C
C	SET BIT IN GP POINT TO ALARM PER POINT
C
	N=((I-1)/16)+1	!CALCULATE WHICH PACKED GROUP POINT
	P=MOD(I-1,16)	!CALCULATE WHICH BIT TO SET
	gp_val_mask(N)=IBSET(gp_val_mask(N),P)	!SET THE BIT
C
	GOTO 345		!GO WRITE TABLE BACK...CONTINUE PROCESSING
C
99999	CONTINUE
C
	CALL	EXIT
C
	END
