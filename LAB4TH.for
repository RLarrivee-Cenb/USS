CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C	CONFIDENTIAL
C	Property of United States Steel Corporation
C	Copyright 2007 United States Steel Corporation
C	All rights reserved.
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	PROGRAM	LAB4TH
C
C	PROGRAM SENDS TO A FILE INFORMATION ON WHICH
C	PLANT EQUIPMENT IS AVAILABLE FOR SAMPLING
C
	IMPLICIT NONE
C
	STRUCTURE	/LAB/
C
		INTEGER*4	CNTR		!1 MIN RUNS TILL END OF DAY
		INTEGER*4	DCNTR		!DAY COUNTER
		INTEGER*4	MCNTR(5)	!15 MIN CONSECUTIVE COUNTER
		INTEGER*4	DAYSX(5)	!DAY AND TIME OF START OF 
		INTEGER*4	TIMX(5)		!DOWN TIME
		INTEGER*4	LDAYSX(5)       !DAY AND TIME OF LAST
		INTEGER*4	LTIMX(5)	!15 MIN CONSECUTIVE DOWN TIME
C
		CHARACTER*3	CNCLNE(16)	!CONCENTRATOR LINES
		CHARACTER*3	CNCIND(16)	!PSM SAMPLE INDICATIONS
		CHARACTER*3	STONE		!LIMESTONE
		CHARACTER*3	PSM(3)		!PSMS 
		CHARACTER*3	NOLA(2)		!NOLAS
		CHARACTER*3	GRATE(5)	!AGGL GRATES
		CHARACTER*3	FLUX(5)		!FLUX LINES
		CHARACTER*3	SAMP(5)		!DO WE SAMPLE
		CHARACTER*3	COL(4)
		REAL*4		ELAKE		!ERICKSON LAKE INTAKE
C
	END STRUCTURE
C
	RECORD/LAB/LAB	
C
	INTEGER*4	SBMCX(16)/527,531,536,540,544,548,
	1			  552,556,560,564,568,
	1			  572,576,580,584,588/
	INTEGER*4	SAMPLE(16)/0,0,0,0,0,0,0,0,0,0,
	1			  1899,1900,1901,1902,1903,1904/
	INTEGER*4	UFO_OPEN,TEMP,TEMPX
	INTEGER*4	ADDRESS(2),BIT
	INTEGER*4	LN2/1778/
	INTEGER*4	PSMCX(3)/1589,1591,1593/
	INTEGER*4	COLMN(4)/1779,1780,1781,1782/
	INTEGER*4	NOLACX(2)/1753,1754/
	INTEGER*4	GRATECX(5)/1258,362,569,349,356/
	INTEGER*4	FLUXCX(8)/69,70,71,1638,816,817,818,819/
	INTEGER*4	I,J,K,L,N,M
C	INTEGER*4	SYS$CANWAK
	INTEGER*4	NUM(4)/50,51,52,53/
C
	REAL*4		PM2400/86400/,TIMS
	REAL*4		ANVAL(1200)
C
	CHARACTER*13	FILE/'GP:LABSAM.DAT'/
	CHARACTER*8	TIME/'0 0:1:00'/	!PROGRAM RUN FREQUENCY
	CHARACTER*6	NAMEX/'LAB4TH'/
C
	COMMON/ANVALTBL/ANVAL
C
	EXTERNAL	UFO_OPEN
C
10	CONTINUE
C
	OPEN	(UNIT=1,FILE='GP:LABSAM.DAT',STATUS='OLD',
	1	FORM='UNFORMATTED',RECL=71,RECORDTYPE='FIXED',
	1	ACCESS='DIRECT',USEROPEN=UFO_OPEN,SHARED)
C
	READ	(1,REC=1)LAB
C
	TIMS=SECNDS(0.0)			!SECONDS SINCE MIDNIGHT
C
	LAB.CNTR=(PM2400-TIMS)/60		!RUNS LEFT TILL END OF DAY
C
	WRITE	(1,REC=1)LAB
C
	CLOSE	(UNIT=1)
C
	CALL	SYS$BINTIM(TIME,ADDRESS)	!CONVERT ASCII TIME TO BINARY
	CALL	SYS$SCHDWK(,,ADDRESS,ADDRESS)	!PUT PROG ON 10 SEC SCHED
C
20 	CONTINUE
C
	TIMS=SECNDS(0.0)			!SECONDS SINCE MIDNIGHT
	TEMPX=TIMS
C
	OPEN	(UNIT=1,FILE='GP:LABSAM.DAT',STATUS='OLD',
	1	FORM='UNFORMATTED',RECL=71,RECORDTYPE='FIXED',
	1	ACCESS='DIRECT',USEROPEN=UFO_OPEN,SHARED)
C
	READ	(1,REC=1)LAB
C
	DO 30	I=1,16
C
		CALL	CHKCX(SBMCX(I),BIT)	!CHECK CONC LINES RUNNING
C
		IF (BIT .EQ. 1)THEN
			WRITE	(LAB.CNCLNE(I),'(I3)')I+2!CONVERT TO ASCII 
		ELSE
			LAB.CNCLNE(I)='   '
		END IF
C
		IF (I .LT. 11)THEN
			LAB.CNCIND(I)='   '
		ELSE
			CALL	CHKCX(SAMPLE(I),BIT)	!CHECK TO SAMPLE
			IF (BIT .EQ. 1)THEN
				LAB.CNCIND(I)='  Y'
			ELSE
				LAB.CNCIND(I)='   '
			END IF
		END IF
C
30	CONTINUE
C
	DO 40	I=1,3
C
		CALL	CHKCX(PSMCX(I),BIT)	!CHECK PSM'S RUNNING
C
		IF (BIT .EQ. 1)THEN
			WRITE	(LAB.PSM(I),'(I3)')I !CONVERT TO ASCII 
		ELSE
			LAB.PSM(I)='   '
		END IF
C
40	CONTINUE
C
	DO 50	I=1,2
C
		CALL	CHKCX(NOLACX(I),BIT)	!CHECK NOLA'S RUNNING
C
		IF (BIT .EQ. 1)THEN
			WRITE	(LAB.NOLA(I),'(I3)')I+1 !CONVERT TO ASCII 
		ELSE
			LAB.NOLA(I)='   '
		END IF
C
50	CONTINUE
C
	DO 60	I=1,5
C
		IF (I .LT. 4)THEN	!IF STEP 1-2
			CALL	CHKAG2(GRATECX(I),BIT)	!CHECK GRATES RUNNING
		ELSE
			CALL	CHKAG3(GRATECX(I),BIT)	!CHECK GRATES RUNNING
		END IF
C
		IF (BIT .EQ. 1)THEN
C
			LAB.GRATE(I)='  Y'
51			CONTINUE
C
			LAB.MCNTR(I)=0
			LAB.DAYSX(I)=0
			LAB.TIMX(I)=0
C
52			CONTINUE
C
			LAB.SAMP(I)='  Y'	!ASSUME WE CAN SAMPLE
C
			IF (LAB.LDAYSX(I) .EQ. 0)GOTO 60 !NO DOWN TIME TO CHECK
C
			TEMP=((LAB.DCNTR-LAB.LDAYSX(I))*86400)
	1		+TEMPX-LAB.LTIMX(I)
C
			IF (TEMP .GT. 5400)THEN
				LAB.LDAYSX(I)=0
				LAB.LTIMX(I)=0
				GOTO 60
			ELSE
				LAB.SAMP(I)='  N'
				GOTO 60
			END IF
C
		ELSE
			LAB.GRATE(I)='  N'
			LAB.MCNTR(I)=LAB.MCNTR(I)+1 !BUMP CONSEC MIN COUNTER
C
			IF (LAB.MCNTR(I) .EQ. 1)THEN !IF THIS IS START
				LAB.DAYSX(I)=LAB.DCNTR !RECORD DAY AND TIME OF
				LAB.TIMX(I)=TEMPX      !START OF DOWN TIME
			END IF
C
			IF (LAB.MCNTR(I) .EQ. 15)THEN !IF 15 MIN OF CONSEC
				LAB.LDAYSX(I)=LAB.DAYSX(I) !DOWN TIME SAVE TIME
				LAB.LTIMX(I)=LAB.TIMX(I)   !DATE OF LAST 15 MIN
				GOTO 51
			ELSE
				GOTO 52
			END IF
C

		END IF
C
60	CONTINUE
C
	LAB.FLUX(1)='  A'	!INDICATE ACID
	LAB.FLUX(2)='  A'	!INDICATE ACID
	LAB.FLUX(3)='  A'	!INDICATE ACID
	LAB.FLUX(4)='  A'	!INDICATE ACID
	LAB.FLUX(5)='  A'	!INDICATE ACID
C
	DO 70	I=1,4
C
			CALL	CHKAG2(FLUXCX(I),BIT)	!CHECK FLUX PMP RUNNING
C
		IF (BIT .EQ. 1)THEN
			LAB.FLUX(1)='  F'
			LAB.FLUX(2)='  F'
			LAB.FLUX(3)='  F'
		END IF
C
70	CONTINUE
C
	DO 80	I=5,8
C
			CALL	CHKAG3(FLUXCX(I),BIT)	!CHECK FLUX PMP RUNNING
C
		IF (BIT .EQ. 1)THEN
			LAB.FLUX(4)='  F'
			LAB.FLUX(5)='  F'
		END IF
C
80	CONTINUE
C
C
	CALL	CHKCX(LN2,BIT)	!CHECK LIMESTONE GRINDING
C
	IF (BIT .EQ. 1)THEN
		LAB.STONE=' ON'
	ELSE
		LAB.STONE='OFF'
	END IF
C
	DO 90	I=1,4
C
		CALL	CHKCX(COLMN(I),BIT)	!CHECK COLUMN'S RUNNING
C
		IF (BIT .EQ. 1)THEN
			WRITE	(LAB.COL(I),'(I3)')NUM(I) !CONVERT TO ASCII 
		ELSE
			LAB.COL(I)='   '
		END IF
C
90	CONTINUE
C
	LAB.CNTR=LAB.CNTR-1
C
	IF (LAB.CNTR .LT. 0)THEN
		LAB.DCNTR=LAB.DCNTR+1	!BUMP DAY COUNTER
		LAB.CNTR=1439
	END IF
C
	LAB.ELAKE=ANVAL(553)	!ERICKSON LAKE PCT SOLIDS
C
	WRITE	(1,REC=1)LAB
C
	CLOSE	(UNIT=1)
C
	CALL	SYS$HIBER()
C
	IF (LAB.CNTR .EQ. 1439)THEN
		CALL	SYS$CANWAK(,NAMEX)
		GOTO 10
	END IF
C
	GOTO 20
C
	END
C
	SUBROUTINE	CHKCX(POINT,BIT)
C
C	SUBROUTINE WILL RETURN THE STATUS OF A CONTACT (0 OR 1)
C
	INTEGER*4	BIT,POINT,I,J,CXSTS(100)
C
	COMMON/CONTACTSCNC/CXSTS	!CONTACT STATUS TABLE
C
	I=(POINT/32)+1		!WORD IN TABLE
	J=MOD(POINT,32)		!BIT IN WORD
	BIT=JIBITS(CXSTS(I),J,1)!EXTRACT BIT
	RETURN
	END
	SUBROUTINE	CHKAG2(POINT,BIT)
C
C	SUBROUTINE WILL RETURN THE STATUS OF A CONTACT (0 OR 1)
C
	INTEGER*4	BIT,POINT,I,J,CXSTSAG2(100)
C
	COMMON/CONTACTS/CXSTSAG2	!CONTACT STATUS TABLE
C
	I=(POINT/32)+1		!WORD IN TABLE
	J=MOD(POINT,32)		!BIT IN WORD
	BIT=JIBITS(CXSTSAG2(I),J,1)!EXTRACT BIT
	RETURN
	END
	SUBROUTINE	CHKAG3(POINT,BIT)
C
C	SUBROUTINE WILL RETURN THE STATUS OF A CONTACT (0 OR 1)
C
	INTEGER*4	BIT,POINT,I,J,CXSTSAG3(100)
C
	COMMON/CONTACTSAG3/CXSTSAG3	!CONTACT STATUS TABLE
C
	I=(POINT/32)+1		!WORD IN TABLE
	J=MOD(POINT,32)		!BIT IN WORD
	BIT=JIBITS(CXSTSAG3(I),J,1)!EXTRACT BIT
	RETURN
	END
